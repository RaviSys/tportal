<!DOCTYPE html>
<html lang="en">
<head>
    <title>selectize.js</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        
        <h1>
            selectize.js
        </h1>
        <ul class="files">
            
            <li>
                app/assets/javascripts/admin/selectize.js
                
            </li>
            <li>Last modified: 2019-03-19 11:34:36 +0530</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<pre><code>sifter.js
Copyright (c) 2013 Brian Reavis &amp; contributors

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this
file except in compliance with the License. You may obtain a copy of the License at:
http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.

@author Brian Reavis &lt;brian@thirdroute.com&gt;
</code></pre>

<p>(function(root, factory) {</p>

<pre><code>if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
  define(&#39;sifter&#39;, factory);
} else if (typeof exports === &#39;object&#39;) {
  module.exports = factory();
} else {
  root.Sifter = factory();
}
</code></pre>

<p>}(this, function() {</p>

<pre><code>   Textually searches arrays and hashes of objects
   by property (or multiple properties). Designed
   specifically for autocomplete.

   @constructor
   @param {array|object} items
   @param {object} items
  /
var Sifter = function(items, settings) {
  this.items = items;
  this.settings = settings || {diacritics: true};
};

/**
   Splits a search string into an array of individual
   regexps to be used to match results.

   @param {string} query
   @returns {array}
  /
Sifter.prototype.tokenize = function(query) {
  query = trim(String(query || &#39;&#39;).toLowerCase());
  if (!query || !query.length) return [];

  var i, n, regex, letter;
  var tokens = [];
  var words = query.split(/ +/);

  for (i = 0, n = words.length; i &lt; n; i++) {
    regex = escape_regex(words[i]);
    if (this.settings.diacritics) {
      for (letter in DIACRITICS) {
        if (DIACRITICS.hasOwnProperty(letter)) {
          regex = regex.replace(new RegExp(letter, &#39;g&#39;), DIACRITICS[letter]);
        }
      }
    }
    tokens.push({
      string : words[i],
      regex  : new RegExp(regex, &#39;i&#39;)
    });
  }

  return tokens;
};

/**
   Iterates over arrays and hashes.

   ```
   this.iterator(this.items, function(item, id) {
      // invoked for each item
   });
   ```

   @param {array|object} object
  /
Sifter.prototype.iterator = function(object, callback) {
  var iterator;
  if (is_array(object)) {
    iterator = Array.prototype.forEach || function(callback) {
      for (var i = 0, n = this.length; i &lt; n; i++) {
        callback(this[i], i, this);
      }
    };
  } else {
    iterator = function(callback) {
      for (var key in this) {
        if (this.hasOwnProperty(key)) {
          callback(this[key], key, this);
        }
      }
    };
  }

  iterator.apply(object, [callback]);
};

/**
   Returns a function to be used to score individual results.

   Good matches will have a higher score than poor matches.
   If an item is not a match, 0 will be returned by the function.

   @param {object|string} search
   @param {object} options (optional)
   @returns {function}
  /
Sifter.prototype.getScoreFunction = function(search, options) {
  var self, fields, tokens, token_count, nesting;

  self        = this;
  search      = self.prepareSearch(search, options);
  tokens      = search.tokens;
  fields      = search.options.fields;
  token_count = tokens.length;
  nesting     = search.options.nesting;

  /**
     Calculates how close of a match the
     given value is against a search token.

     @param {mixed} value
     @param {object} token
     @return {number}
    /
  var scoreValue = function(value, token) {
    var score, pos;

    if (!value) return 0;
    value = String(value || &#39;&#39;);
    pos = value.search(token.regex);
    if (pos === -1) return 0;
    score = token.string.length / value.length;
    if (pos === 0) score += 0.5;
    return score;
  };

  /**
     Calculates the score of an object
     against the search query.

     @param {object} token
     @param {object} data
     @return {number}
    /
  var scoreObject = (function() {
    var field_count = fields.length;
    if (!field_count) {
      return function() { return 0; };
    }
    if (field_count === 1) {
      return function(token, data) {
        return scoreValue(getattr(data, fields[0], nesting), token);
      };
    }
    return function(token, data) {
      for (var i = 0, sum = 0; i &lt; field_count; i++) {
        sum += scoreValue(getattr(data, fields[i], nesting), token);
      }
      return sum / field_count;
    };
  })();

  if (!token_count) {
    return function() { return 0; };
  }
  if (token_count === 1) {
    return function(data) {
      return scoreObject(tokens[0], data);
    };
  }

  if (search.options.conjunction === &#39;and&#39;) {
    return function(data) {
      var score;
      for (var i = 0, sum = 0; i &lt; token_count; i++) {
        score = scoreObject(tokens[i], data);
        if (score &lt;= 0) return 0;
        sum += score;
      }
      return sum / token_count;
    };
  } else {
    return function(data) {
      for (var i = 0, sum = 0; i &lt; token_count; i++) {
        sum += scoreObject(tokens[i], data);
      }
      return sum / token_count;
    };
  }
};

/**
   Returns a function that can be used to compare two
   results, for sorting purposes. If no sorting should
   be performed, `null` will be returned.

   @param {string|object} search
   @param {object} options
   @return function(a,b)
  /
Sifter.prototype.getSortFunction = function(search, options) {
  var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;

  self   = this;
  search = self.prepareSearch(search, options);
  sort   = (!search.query &amp;&amp; options.sort_empty) || options.sort;

  /**
     Fetches the specified sort field value
     from a search result item.

     @param  {string} name
     @param  {object} result
     @return {mixed}
    /
  get_field = function(name, result) {
    if (name === &#39;$score&#39;) return result.score;
    return getattr(self.items[result.id], name, options.nesting);
  };

  // parse options
  fields = [];
  if (sort) {
    for (i = 0, n = sort.length; i &lt; n; i++) {
      if (search.query || sort[i].field !== &#39;$score&#39;) {
        fields.push(sort[i]);
      }
    }
  }

  // the &quot;$score&quot; field is implied to be the primary
  // sort field, unless it&#39;s manually specified
  if (search.query) {
    implicit_score = true;
    for (i = 0, n = fields.length; i &lt; n; i++) {
      if (fields[i].field === &#39;$score&#39;) {
        implicit_score = false;
        break;
      }
    }
    if (implicit_score) {
      fields.unshift({field: &#39;$score&#39;, direction: &#39;desc&#39;});
    }
  } else {
    for (i = 0, n = fields.length; i &lt; n; i++) {
      if (fields[i].field === &#39;$score&#39;) {
        fields.splice(i, 1);
        break;
      }
    }
  }

  multipliers = [];
  for (i = 0, n = fields.length; i &lt; n; i++) {
    multipliers.push(fields[i].direction === &#39;desc&#39; ? -1 : 1);
  }

  // build function
  fields_count = fields.length;
  if (!fields_count) {
    return null;
  } else if (fields_count === 1) {
    field = fields[0].field;
    multiplier = multipliers[0];
    return function(a, b) {
      return multiplier * cmp(
        get_field(field, a),
        get_field(field, b)
      );
    };
  } else {
    return function(a, b) {
      var i, result, a_value, b_value, field;
      for (i = 0; i &lt; fields_count; i++) {
        field = fields[i].field;
        result = multipliers[i] * cmp(
          get_field(field, a),
          get_field(field, b)
        );
        if (result) return result;
      }
      return 0;
    };
  }
};

/**
   Parses a search query and returns an object
   with tokens and fields ready to be populated
   with results.

   @param {string} query
   @param {object} options
   @returns {object}
  /
Sifter.prototype.prepareSearch = function(query, options) {
  if (typeof query === &#39;object&#39;) return query;

  options = extend({}, options);

  var option_fields     = options.fields;
  var option_sort       = options.sort;
  var option_sort_empty = options.sort_empty;

  if (option_fields &amp;&amp; !is_array(option_fields)) options.fields = [option_fields];
  if (option_sort &amp;&amp; !is_array(option_sort)) options.sort = [option_sort];
  if (option_sort_empty &amp;&amp; !is_array(option_sort_empty)) options.sort_empty = [option_sort_empty];

  return {
    options : options,
    query   : String(query || &#39;&#39;).toLowerCase(),
    tokens  : this.tokenize(query),
    total   : 0,
    items   : []
  };
};

/**
   Searches through all items and returns a sorted array of matches.

   The `options` parameter can contain:

     - fields {string|array}
     - sort {array}
     - score {function}
     - filter {bool}
     - limit {integer}

   Returns an object containing:

     - options {object}
     - query {string}
     - tokens {array}
     - total {int}
     - items {array}

   @param {string} query
   @param {object} options
   @returns {object}
  /
Sifter.prototype.search = function(query, options) {
  var self = this, value, score, search, calculateScore;
  var fn_sort;
  var fn_score;

  search  = this.prepareSearch(query, options);
  options = search.options;
  query   = search.query;

  // generate result scoring function
  fn_score = options.score || self.getScoreFunction(search);

  // perform search and sort
  if (query.length) {
    self.iterator(self.items, function(item, id) {
      score = fn_score(item);
      if (options.filter === false || score &gt; 0) {
        search.items.push({&#39;score&#39;: score, &#39;id&#39;: id});
      }
    });
  } else {
    self.iterator(self.items, function(item, id) {
      search.items.push({&#39;score&#39;: 1, &#39;id&#39;: id});
    });
  }

  fn_sort = self.getSortFunction(search, options);
  if (fn_sort) search.items.sort(fn_sort);

  // apply limits
  search.total = search.items.length;
  if (typeof options.limit === &#39;number&#39;) {
    search.items = search.items.slice(0, options.limit);
  }

  return search;
};

// utilities
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

var cmp = function(a, b) {
  if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {
    return a &gt; b ? 1 : (a &lt; b ? -1 : 0);
  }
  a = asciifold(String(a || &#39;&#39;));
  b = asciifold(String(b || &#39;&#39;));
  if (a &gt; b) return 1;
  if (b &gt; a) return -1;
  return 0;
};

var extend = function(a, b) {
  var i, n, k, object;
  for (i = 1, n = arguments.length; i &lt; n; i++) {
    object = arguments[i];
    if (!object) continue;
    for (k in object) {
      if (object.hasOwnProperty(k)) {
        a[k] = object[k];
      }
    }
  }
  return a;
};

/**
   A property getter resolving dot-notation
   @param  {Object}  obj     The root object to fetch property on
   @param  {String}  name    The optionally dotted property name to fetch
   @param  {Boolean} nesting Handle nesting or not
   @return {Object}          The resolved property value
  /
var getattr = function(obj, name, nesting) {
    if (!obj || !name) return;
    if (!nesting) return obj[name];
    var names = name.split(&quot;.&quot;);
    while(names.length &amp;&amp; (obj = obj[names.shift()]));
    return obj;
};

var trim = function(str) {
  return (str + &#39;&#39;).replace(/^\s+|\s+$|/g, &#39;&#39;);
};

var escape_regex = function(str) {
  return (str + &#39;&#39;).replace(/([.?*+^$[\]\\(){}|-])/g, &#39;\\$1&#39;);
};

var is_array = Array.isArray || (typeof $ !== &#39;undefined&#39; &amp;&amp; $.isArray) || function(object) {
  return Object.prototype.toString.call(object) === &#39;[object Array]&#39;;
};

var DIACRITICS = {
  &#39;a&#39;: &#39;[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]&#39;,
  &#39;b&#39;: &#39;[b␢βΒB฿𐌁ᛒ]&#39;,
  &#39;c&#39;: &#39;[cĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃ]&#39;,
  &#39;d&#39;: &#39;[dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]&#39;,
  &#39;e&#39;: &#39;[eÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐε]&#39;,
  &#39;f&#39;: &#39;[fƑƒḞḟ]&#39;,
  &#39;g&#39;: &#39;[gɢ₲ǤǥĜĝĞğĢģƓɠĠġ]&#39;,
  &#39;h&#39;: &#39;[hĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕ]&#39;,
  &#39;i&#39;: &#39;[iÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉ]&#39;,
  &#39;j&#39;: &#39;[jȷĴĵɈɉʝɟʲ]&#39;,
  &#39;k&#39;: &#39;[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭]&#39;,
  &#39;l&#39;: &#39;[lŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌ]&#39;,
  &#39;n&#39;: &#39;[nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]&#39;,
  &#39;o&#39;: &#39;[oØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօ]&#39;,
  &#39;p&#39;: &#39;[pṔṕṖṗⱣᵽƤƥᵱ]&#39;,
  &#39;q&#39;: &#39;[qꝖꝗʠɊɋꝘꝙq̃]&#39;,
  &#39;r&#39;: &#39;[rŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽ]&#39;,
  &#39;s&#39;: &#39;[sŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈]&#39;,
  &#39;t&#39;: &#39;[tŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭ]&#39;,
  &#39;u&#39;: &#39;[uŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪]&#39;,
  &#39;v&#39;: &#39;[vṼṽṾṿƲʋꝞꝟⱱʋ]&#39;,
  &#39;w&#39;: &#39;[wẂẃẀẁŴŵẄẅẆẇẈẉ]&#39;,
  &#39;x&#39;: &#39;[xẌẍẊẋχ]&#39;,
  &#39;y&#39;: &#39;[yÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴ]&#39;,
  &#39;z&#39;: &#39;[zŹźẐẑŽžŻżẒẓẔẕƵƶ]&#39;
};

var asciifold = (function() {
  var i, n, k, chunk;
  var foreignletters = &#39;&#39;;
  var lookup = {};
  for (k in DIACRITICS) {
    if (DIACRITICS.hasOwnProperty(k)) {
      chunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);
      foreignletters += chunk;
      for (i = 0, n = chunk.length; i &lt; n; i++) {
        lookup[chunk.charAt(i)] = k;
      }
    }
  }
  var regexp = new RegExp(&#39;[&#39; +  foreignletters + &#39;]&#39;, &#39;g&#39;);
  return function(str) {
    return str.replace(regexp, function(foreignletter) {
      return lookup[foreignletter];
    }).toLowerCase();
  };
})();

// export
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

return Sifter;
</code></pre>

<p>}));</p>

<p>/**</p>

<pre><code> microplugin.js
 Copyright (c) 2013 Brian Reavis &amp; contributors

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this
 file except in compliance with the License. You may obtain a copy of the License at:
 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under
 the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 ANY KIND, either express or implied. See the License for the specific language
 governing permissions and limitations under the License.

 @author Brian Reavis &lt;brian@thirdroute.com&gt;
/
</code></pre>

<p>(function(root, factory) {</p>

<pre><code>if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
  define(&#39;microplugin&#39;, factory);
} else if (typeof exports === &#39;object&#39;) {
  module.exports = factory();
} else {
  root.MicroPlugin = factory();
}
</code></pre>

<p>}(this, function() {</p>

<pre><code>var MicroPlugin = {};

MicroPlugin.mixin = function(Interface) {
  Interface.plugins = {};

  /**
     Initializes the listed plugins (with options).
     Acceptable formats:

     List (without options):
       [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

     List (with options):
       [{&#39;name&#39;: &#39;a&#39;, options: {}}, {&#39;name&#39;: &#39;b&#39;, options: {}}]

     Hash (with options):
       {&#39;a&#39;: { ... }, &#39;b&#39;: { ... }, &#39;c&#39;: { ... }}

     @param {mixed} plugins
    /
  Interface.prototype.initializePlugins = function(plugins) {
    var i, n, key;
    var self  = this;
    var queue = [];

    self.plugins = {
      names     : [],
      settings  : {},
      requested : {},
      loaded    : {}
    };

    if (utils.isArray(plugins)) {
      for (i = 0, n = plugins.length; i &lt; n; i++) {
        if (typeof plugins[i] === &#39;string&#39;) {
          queue.push(plugins[i]);
        } else {
          self.plugins.settings[plugins[i].name] = plugins[i].options;
          queue.push(plugins[i].name);
        }
      }
    } else if (plugins) {
      for (key in plugins) {
        if (plugins.hasOwnProperty(key)) {
          self.plugins.settings[key] = plugins[key];
          queue.push(key);
        }
      }
    }

    while (queue.length) {
      self.require(queue.shift());
    }
  };

  Interface.prototype.loadPlugin = function(name) {
    var self    = this;
    var plugins = self.plugins;
    var plugin  = Interface.plugins[name];

    if (!Interface.plugins.hasOwnProperty(name)) {
      throw new Error(&#39;Unable to find &quot;&#39; +  name + &#39;&quot; plugin&#39;);
    }

    plugins.requested[name] = true;
    plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
    plugins.names.push(name);
  };

  /**
     Initializes a plugin.

     @param {string} name
    /
  Interface.prototype.require = function(name) {
    var self = this;
    var plugins = self.plugins;

    if (!self.plugins.loaded.hasOwnProperty(name)) {
      if (plugins.requested[name]) {
        throw new Error(&#39;Plugin has circular dependency (&quot;&#39; + name + &#39;&quot;)&#39;);
      }
      self.loadPlugin(name);
    }

    return plugins.loaded[name];
  };

  /**
     Registers a plugin.

     @param {string} name
     @param {function} fn
    /
  Interface.define = function(name, fn) {
    Interface.plugins[name] = {
      &#39;name&#39; : name,
      &#39;fn&#39;   : fn
    };
  };
};

var utils = {
  isArray: Array.isArray || function(vArg) {
    return Object.prototype.toString.call(vArg) === &#39;[object Array]&#39;;
  }
};

return MicroPlugin;
</code></pre>

<p>}));</p>

<p>/**</p>

<pre><code> selectize.js (v0.12.4)
 Copyright (c) 2013–2015 Brian Reavis &amp; contributors

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this
 file except in compliance with the License. You may obtain a copy of the License at:
 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under
 the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 ANY KIND, either express or implied. See the License for the specific language
 governing permissions and limitations under the License.

 @author Brian Reavis &lt;brian@thirdroute.com&gt;
/
</code></pre>

<p>/*jshint curly:false</p>

<p>/*jshint browser:true */</p>

<p>(function(root, factory) {</p>

<pre><code>if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
  define(&#39;selectize&#39;, [&#39;jquery&#39;,&#39;sifter&#39;,&#39;microplugin&#39;], factory);
} else if (typeof exports === &#39;object&#39;) {
  module.exports = factory(require(&#39;jquery&#39;), require(&#39;sifter&#39;), require(&#39;microplugin&#39;));
} else {
  root.Selectize = factory(root.jQuery, root.Sifter, root.MicroPlugin);
}
</code></pre>

<p>}(this, function($, Sifter, MicroPlugin) {</p>

<pre><code>&#39;use strict&#39;;

var highlight = function($element, pattern) {
  if (typeof pattern === &#39;string&#39; &amp;&amp; !pattern.length) return;
  var regex = (typeof pattern === &#39;string&#39;) ? new RegExp(pattern, &#39;i&#39;) : pattern;

  var highlight = function(node) {
    var skip = 0;
    if (node.nodeType === 3) {
      var pos = node.data.search(regex);
      if (pos &gt;= 0 &amp;&amp; node.data.length &gt; 0) {
        var match = node.data.match(regex);
        var spannode = document.createElement(&#39;span&#39;);
        spannode.className = &#39;highlight&#39;;
        var middlebit = node.splitText(pos);
        var endbit = middlebit.splitText(match[0].length);
        var middleclone = middlebit.cloneNode(true);
        spannode.appendChild(middleclone);
        middlebit.parentNode.replaceChild(spannode, middlebit);
        skip = 1;
      }
    } else if (node.nodeType === 1 &amp;&amp; node.childNodes &amp;&amp; !/(script|style)/i.test(node.tagName)) {
      for (var i = 0; i &lt; node.childNodes.length; ++i) {
        i += highlight(node.childNodes[i]);
      }
    }
    return skip;
  };

  return $element.each(function() {
    highlight(this);
  });
};

/**
   removeHighlight fn copied from highlight v5 and
   edited to remove with() and pass js strict mode
  /
$.fn.removeHighlight = function() {
  return this.find(&quot;span.highlight&quot;).each(function() {
    this.parentNode.firstChild.nodeName;
    var parent = this.parentNode;
    parent.replaceChild(this.firstChild, this);
    parent.normalize();
  }).end();
};

var MicroEvent = function() {};
MicroEvent.prototype = {
  on: function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  off: function(event, fct){
    var n = arguments.length;
    if (n === 0) return delete this._events;
    if (n === 1) return delete this._events[event];

    this._events = this._events || {};
    if (event in this._events === false) return;
    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  trigger: function(event /* , args... */){
    this._events = this._events || {};
    if (event in this._events === false) return;
    for (var i = 0; i &lt; this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
   Mixin will delegate all MicroEvent.js function in the destination object.

   - MicroEvent.mixin(Foobar) will make Foobar able to use MicroEvent

   @param {object} the object which will support MicroEvent
  /
MicroEvent.mixin = function(destObject){
  var props = [&#39;on&#39;, &#39;off&#39;, &#39;trigger&#39;];
  for (var i = 0; i &lt; props.length; i++){
    destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
  }
};

var IS_MAC        = /Mac/.test(navigator.userAgent);

var KEY_A         = 65;
var KEY_COMMA     = 188;
var KEY_RETURN    = 13;
var KEY_ESC       = 27;
var KEY_LEFT      = 37;
var KEY_UP        = 38;
var KEY_P         = 80;
var KEY_RIGHT     = 39;
var KEY_DOWN      = 40;
var KEY_N         = 78;
var KEY_BACKSPACE = 8;
var KEY_DELETE    = 46;
var KEY_SHIFT     = 16;
var KEY_CMD       = IS_MAC ? 91 : 17;
var KEY_CTRL      = IS_MAC ? 18 : 17;
var KEY_TAB       = 9;

var TAG_SELECT    = 1;
var TAG_INPUT     = 2;

// for now, android support in general is too spotty to support validity
var SUPPORTS_VALIDITY_API = !/android/i.test(window.navigator.userAgent) &amp;&amp; !!document.createElement(&#39;input&#39;).validity;

var isset = function(object) {
  return typeof object !== &#39;undefined&#39;;
};

/**
   Converts a scalar to its best string representation
   for hash keys and HTML attribute values.

   Transformations:
     &#39;str&#39;     -&gt; &#39;str&#39;
     null      -&gt; &#39;&#39;
     undefined -&gt; &#39;&#39;
     true      -&gt; &#39;1&#39;
     false     -&gt; &#39;0&#39;
     0         -&gt; &#39;0&#39;
     1         -&gt; &#39;1&#39;

   @param {string} value
   @returns {string|null}
  /
var hash_key = function(value) {
  if (typeof value === &#39;undefined&#39; || value === null) return null;
  if (typeof value === &#39;boolean&#39;) return value ? &#39;1&#39; : &#39;0&#39;;
  return value + &#39;&#39;;
};

/**
   Escapes a string for use within HTML.

   @param {string} str
   @returns {string}
  /
var escape_html = function(str) {
  return (str + &#39;&#39;)
    .replace(/&amp;/g, &#39;&amp;amp;&#39;)
    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
    .replace(/&gt;/g, &#39;&amp;gt;&#39;)
    .replace(/&quot;/g, &#39;&amp;quot;&#39;);
};

/**
   Escapes &quot;$&quot; characters in replacement strings.

   @param {string} str
   @returns {string}
  /
var escape_replace = function(str) {
  return (str + &#39;&#39;).replace(/\$/g, &#39;$$$$&#39;);
};

var hook = {};

/**
   Wraps `method` on `self` so that `fn`
   is invoked before the original method.

   @param {object} self
   @param {string} method
   @param {function} fn
  /
hook.before = function(self, method, fn) {
  var original = self[method];
  self[method] = function() {
    fn.apply(self, arguments);
    return original.apply(self, arguments);
  };
};

/**
   Wraps `method` on `self` so that `fn`
   is invoked after the original method.

   @param {object} self
   @param {string} method
   @param {function} fn
  /
hook.after = function(self, method, fn) {
  var original = self[method];
  self[method] = function() {
    var result = original.apply(self, arguments);
    fn.apply(self, arguments);
    return result;
  };
};

/**
   Wraps `fn` so that it can only be invoked once.

   @param {function} fn
   @returns {function}
  /
var once = function(fn) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    fn.apply(this, arguments);
  };
};

/**
   Wraps `fn` so that it can only be called once
   every `delay` milliseconds (invoked on the falling edge).

   @param {function} fn
   @param {int} delay
   @returns {function}
  /
var debounce = function(fn, delay) {
  var timeout;
  return function() {
    var self = this;
    var args = arguments;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(function() {
      fn.apply(self, args);
    }, delay);
  };
};

/**
   Debounce all fired events types listed in `types`
   while executing the provided `fn`.

   @param {object} self
   @param {array} types
   @param {function} fn
  /
var debounce_events = function(self, types, fn) {
  var type;
  var trigger = self.trigger;
  var event_args = {};

  // override trigger method
  self.trigger = function() {
    var type = arguments[0];
    if (types.indexOf(type) !== -1) {
      event_args[type] = arguments;
    } else {
      return trigger.apply(self, arguments);
    }
  };

  // invoke provided function
  fn.apply(self, []);
  self.trigger = trigger;

  // trigger queued events
  for (type in event_args) {
    if (event_args.hasOwnProperty(type)) {
      trigger.apply(self, event_args[type]);
    }
  }
};

/**
   A workaround for http://bugs.jquery.com/ticket/6696

   @param {object} $parent - Parent element to listen on.
   @param {string} event - Event name.
   @param {string} selector - Descendant selector to filter by.
   @param {function} fn - Event handler.
  /
var watchChildEvent = function($parent, event, selector, fn) {
  $parent.on(event, selector, function(e) {
    var child = e.target;
    while (child &amp;&amp; child.parentNode !== $parent[0]) {
      child = child.parentNode;
    }
    e.currentTarget = child;
    return fn.apply(this, [e]);
  });
};

/**
   Determines the current selection within a text input control.
   Returns an object containing:
     - start
     - length

   @param {object} input
   @returns {object}
  /
var getSelection = function(input) {
  var result = {};
  if (&#39;selectionStart&#39; in input) {
    result.start = input.selectionStart;
    result.length = input.selectionEnd - result.start;
  } else if (document.selection) {
    input.focus();
    var sel = document.selection.createRange();
    var selLen = document.selection.createRange().text.length;
    sel.moveStart(&#39;character&#39;, -input.value.length);
    result.start = sel.text.length - selLen;
    result.length = selLen;
  }
  return result;
};

/**
   Copies CSS properties from one element to another.

   @param {object} $from
   @param {object} $to
   @param {array} properties
  /
var transferStyles = function($from, $to, properties) {
  var i, n, styles = {};
  if (properties) {
    for (i = 0, n = properties.length; i &lt; n; i++) {
      styles[properties[i]] = $from.css(properties[i]);
    }
  } else {
    styles = $from.css();
  }
  $to.css(styles);
};

/**
   Measures the width of a string within a
   parent element (in pixels).

   @param {string} str
   @param {object} $parent
   @returns {int}
  /
var measureString = function(str, $parent) {
  if (!str) {
    return 0;
  }

  var $test = $(&#39;&lt;test&gt;&#39;).css({
    position: &#39;absolute&#39;,
    top: -99999,
    left: -99999,
    width: &#39;auto&#39;,
    padding: 0,
    whiteSpace: &#39;pre&#39;
  }).text(str).appendTo(&#39;body&#39;);

  transferStyles($parent, $test, [
    &#39;letterSpacing&#39;,
    &#39;fontSize&#39;,
    &#39;fontFamily&#39;,
    &#39;fontWeight&#39;,
    &#39;textTransform&#39;
  ]);

  var width = $test.width();
  $test.remove();

  return width;
};

/**
   Sets up an input to grow horizontally as the user
   types. If the value is changed manually, you can
   trigger the &quot;update&quot; handler to resize:

   $input.trigger(&#39;update&#39;);

   @param {object} $input
  /
var autoGrow = function($input) {
  var currentWidth = null;

  var update = function(e, options) {
    var value, keyCode, printable, placeholder, width;
    var shift, character, selection;
    e = e || window.event || {};
    options = options || {};

    if (e.metaKey || e.altKey) return;
    if (!options.force &amp;&amp; $input.data(&#39;grow&#39;) === false) return;

    value = $input.val();
    if (e.type &amp;&amp; e.type.toLowerCase() === &#39;keydown&#39;) {
      keyCode = e.keyCode;
      printable = (
        (keyCode &gt;= 97 &amp;&amp; keyCode &lt;= 122) || // a-z
        (keyCode &gt;= 65 &amp;&amp; keyCode &lt;= 90)  || // A-Z
        (keyCode &gt;= 48 &amp;&amp; keyCode &lt;= 57)  || // 0-9
        keyCode === 32 // space
      );

      if (keyCode === KEY_DELETE || keyCode === KEY_BACKSPACE) {
        selection = getSelection($input[0]);
        if (selection.length) {
          value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);
        } else if (keyCode === KEY_BACKSPACE &amp;&amp; selection.start) {
          value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);
        } else if (keyCode === KEY_DELETE &amp;&amp; typeof selection.start !== &#39;undefined&#39;) {
          value = value.substring(0, selection.start) + value.substring(selection.start + 1);
        }
      } else if (printable) {
        shift = e.shiftKey;
        character = String.fromCharCode(e.keyCode);
        if (shift) character = character.toUpperCase();
        else character = character.toLowerCase();
        value += character;
      }
    }

    placeholder = $input.attr(&#39;placeholder&#39;);
    if (!value &amp;&amp; placeholder) {
      value = placeholder;
    }

    width = measureString(value, $input) + 4;
    if (width !== currentWidth) {
      currentWidth = width;
      $input.width(width);
      $input.triggerHandler(&#39;resize&#39;);
    }
  };

  $input.on(&#39;keydown keyup update blur&#39;, update);
  update();
};

var domToString = function(d) {
  var tmp = document.createElement(&#39;div&#39;);

  tmp.appendChild(d.cloneNode(true));

  return tmp.innerHTML;
};

var logError = function(message, options){
  if(!options) options = {};
  var component = &quot;Selectize&quot;;

  console.error(component + &quot;: &quot; + message)

  if(options.explanation){
    // console.group is undefined in &lt;IE11
    if(console.group) console.group();
    console.error(options.explanation);
    if(console.group) console.groupEnd();
  }
}

var Selectize = function($input, settings) {
  var key, i, n, dir, input, self = this;
  input = $input[0];
  input.selectize = self;

  // detect rtl environment
  var computedStyle = window.getComputedStyle &amp;&amp; window.getComputedStyle(input, null);
  dir = computedStyle ? computedStyle.getPropertyValue(&#39;direction&#39;) : input.currentStyle &amp;&amp; input.currentStyle.direction;
  dir = dir || $input.parents(&#39;[dir]:first&#39;).attr(&#39;dir&#39;) || &#39;&#39;;

  // setup default state
  $.extend(self, {
    order            : 0,
    settings         : settings,
    $input           : $input,
    tabIndex         : $input.attr(&#39;tabindex&#39;) || &#39;&#39;,
    tagType          : input.tagName.toLowerCase() === &#39;select&#39; ? TAG_SELECT : TAG_INPUT,
    rtl              : /rtl/i.test(dir),

    eventNS          : &#39;.selectize&#39; + (++Selectize.count),
    highlightedValue : null,
    isOpen           : false,
    isDisabled       : false,
    isRequired       : $input.is(&#39;[required]&#39;),
    isInvalid        : false,
    isLocked         : false,
    isFocused        : false,
    isInputHidden    : false,
    isSetup          : false,
    isShiftDown      : false,
    isCmdDown        : false,
    isCtrlDown       : false,
    ignoreFocus      : false,
    ignoreBlur       : false,
    ignoreHover      : false,
    hasOptions       : false,
    currentResults   : null,
    lastValue        : &#39;&#39;,
    caretPos         : 0,
    loading          : 0,
    loadedSearches   : {},

    $activeOption    : null,
    $activeItems     : [],

    optgroups        : {},
    options          : {},
    userOptions      : {},
    items            : [],
    renderCache      : {},
    onSearchChange   : settings.loadThrottle === null ? self.onSearchChange : debounce(self.onSearchChange, settings.loadThrottle)
  });

  // search system
  self.sifter = new Sifter(this.options, {diacritics: settings.diacritics});

  // build options table
  if (self.settings.options) {
    for (i = 0, n = self.settings.options.length; i &lt; n; i++) {
      self.registerOption(self.settings.options[i]);
    }
    delete self.settings.options;
  }

  // build optgroup table
  if (self.settings.optgroups) {
    for (i = 0, n = self.settings.optgroups.length; i &lt; n; i++) {
      self.registerOptionGroup(self.settings.optgroups[i]);
    }
    delete self.settings.optgroups;
  }

  // option-dependent defaults
  self.settings.mode = self.settings.mode || (self.settings.maxItems === 1 ? &#39;single&#39; : &#39;multi&#39;);
  if (typeof self.settings.hideSelected !== &#39;boolean&#39;) {
    self.settings.hideSelected = self.settings.mode === &#39;multi&#39;;
  }

  self.initializePlugins(self.settings.plugins);
  self.setupCallbacks();
  self.setupTemplates();
  self.setup();
};

// mixins
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

MicroEvent.mixin(Selectize);

if(typeof MicroPlugin !== &quot;undefined&quot;){
  MicroPlugin.mixin(Selectize);
}else{
  logError(&quot;Dependency MicroPlugin is missing&quot;,
    {explanation:
      &quot;Make sure you either: (1) are using the \&quot;standalone\&quot; &quot;+
      &quot;version of Selectize, or (2) require MicroPlugin before you &quot;+
      &quot;load Selectize.&quot;}
  );
}

// methods
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$.extend(Selectize.prototype, {

  /**
     Creates all elements and sets up event bindings.
    /
  setup: function() {
    var self      = this;
    var settings  = self.settings;
    var eventNS   = self.eventNS;
    var $window   = $(window);
    var $document = $(document);
    var $input    = self.$input;

    var $wrapper;
    var $control;
    var $control_input;
    var $dropdown;
    var $dropdown_content;
    var $dropdown_parent;
    var inputMode;
    var timeout_blur;
    var timeout_focus;
    var classes;
    var classes_plugins;
    var inputId;

    inputMode         = self.settings.mode;
    classes           = $input.attr(&#39;class&#39;) || &#39;&#39;;

    $wrapper          = $(&#39;&lt;div&gt;&#39;).addClass(settings.wrapperClass).addClass(classes).addClass(inputMode);
    $control          = $(&#39;&lt;div&gt;&#39;).addClass(settings.inputClass).addClass(&#39;items&#39;).appendTo($wrapper);
    $control_input    = $(&#39;&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; /&gt;&#39;).appendTo($control).attr(&#39;tabindex&#39;, $input.is(&#39;:disabled&#39;) ? &#39;-1&#39; : self.tabIndex);
    $dropdown_parent  = $(settings.dropdownParent || $wrapper);
    $dropdown         = $(&#39;&lt;div&gt;&#39;).addClass(settings.dropdownClass).addClass(inputMode).hide().appendTo($dropdown_parent);
    $dropdown_content = $(&#39;&lt;div&gt;&#39;).addClass(settings.dropdownContentClass).appendTo($dropdown);

    if(inputId = $input.attr(&#39;id&#39;)) {
      $control_input.attr(&#39;id&#39;, inputId + &#39;-selectized&#39;);
      $(&quot;label[for=&#39;&quot;+inputId+&quot;&#39;]&quot;).attr(&#39;for&#39;, inputId + &#39;-selectized&#39;);
    }

    if(self.settings.copyClassesToDropdown) {
      $dropdown.addClass(classes);
    }

    $wrapper.css({
      width: $input[0].style.width
    });

    if (self.plugins.names.length) {
      classes_plugins = &#39;plugin-&#39; + self.plugins.names.join(&#39; plugin-&#39;);
      $wrapper.addClass(classes_plugins);
      $dropdown.addClass(classes_plugins);
    }

    if ((settings.maxItems === null || settings.maxItems &gt; 1) &amp;&amp; self.tagType === TAG_SELECT) {
      $input.attr(&#39;multiple&#39;, &#39;multiple&#39;);
    }

    if (self.settings.placeholder) {
      $control_input.attr(&#39;placeholder&#39;, settings.placeholder);
    }

    // if splitOn was not passed in, construct it from the delimiter to allow pasting universally
    if (!self.settings.splitOn &amp;&amp; self.settings.delimiter) {
      var delimiterEscaped = self.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, &#39;\\$&amp;&#39;);
      self.settings.splitOn = new RegExp(&#39;\\s*&#39; + delimiterEscaped + &#39;+\\s*&#39;);
    }

    if ($input.attr(&#39;autocorrect&#39;)) {
      $control_input.attr(&#39;autocorrect&#39;, $input.attr(&#39;autocorrect&#39;));
    }

    if ($input.attr(&#39;autocapitalize&#39;)) {
      $control_input.attr(&#39;autocapitalize&#39;, $input.attr(&#39;autocapitalize&#39;));
    }

    self.$wrapper          = $wrapper;
    self.$control          = $control;
    self.$control_input    = $control_input;
    self.$dropdown         = $dropdown;
    self.$dropdown_content = $dropdown_content;

    $dropdown.on(&#39;mouseenter&#39;, &#39;[data-selectable]&#39;, function() { return self.onOptionHover.apply(self, arguments); });
    $dropdown.on(&#39;mousedown click&#39;, &#39;[data-selectable]&#39;, function() { return self.onOptionSelect.apply(self, arguments); });
    watchChildEvent($control, &#39;mousedown&#39;, &#39;*:not(input)&#39;, function() { return self.onItemSelect.apply(self, arguments); });
    autoGrow($control_input);

    $control.on({
      mousedown : function() { return self.onMouseDown.apply(self, arguments); },
      click     : function() { return self.onClick.apply(self, arguments); }
    });

    $control_input.on({
      mousedown : function(e) { e.stopPropagation(); },
      keydown   : function() { return self.onKeyDown.apply(self, arguments); },
      keyup     : function() { return self.onKeyUp.apply(self, arguments); },
      keypress  : function() { return self.onKeyPress.apply(self, arguments); },
      resize    : function() { self.positionDropdown.apply(self, []); },
      blur      : function() { return self.onBlur.apply(self, arguments); },
      focus     : function() { self.ignoreBlur = false; return self.onFocus.apply(self, arguments); },
      paste     : function() { return self.onPaste.apply(self, arguments); }
    });

    $document.on(&#39;keydown&#39; + eventNS, function(e) {
      self.isCmdDown = e[IS_MAC ? &#39;metaKey&#39; : &#39;ctrlKey&#39;];
      self.isCtrlDown = e[IS_MAC ? &#39;altKey&#39; : &#39;ctrlKey&#39;];
      self.isShiftDown = e.shiftKey;
    });

    $document.on(&#39;keyup&#39; + eventNS, function(e) {
      if (e.keyCode === KEY_CTRL) self.isCtrlDown = false;
      if (e.keyCode === KEY_SHIFT) self.isShiftDown = false;
      if (e.keyCode === KEY_CMD) self.isCmdDown = false;
    });

    $document.on(&#39;mousedown&#39; + eventNS, function(e) {
      if (self.isFocused) {
        // prevent events on the dropdown scrollbar from causing the control to blur
        if (e.target === self.$dropdown[0] || e.target.parentNode === self.$dropdown[0]) {
          return false;
        }
        // blur on click outside
        if (!self.$control.has(e.target).length &amp;&amp; e.target !== self.$control[0]) {
          self.blur(e.target);
        }
      }
    });

    $window.on([&#39;scroll&#39; + eventNS, &#39;resize&#39; + eventNS].join(&#39; &#39;), function() {
      if (self.isOpen) {
        self.positionDropdown.apply(self, arguments);
      }
    });
    $window.on(&#39;mousemove&#39; + eventNS, function() {
      self.ignoreHover = false;
    });

    // store original children and tab index so that they can be
    // restored when the destroy() method is called.
    this.revertSettings = {
      $children : $input.children().detach(),
      tabindex  : $input.attr(&#39;tabindex&#39;)
    };

    $input.attr(&#39;tabindex&#39;, -1).hide().after(self.$wrapper);

    if ($.isArray(settings.items)) {
      self.setValue(settings.items);
      delete settings.items;
    }

    // feature detect for the validation API
    if (SUPPORTS_VALIDITY_API) {
      $input.on(&#39;invalid&#39; + eventNS, function(e) {
        e.preventDefault();
        self.isInvalid = true;
        self.refreshState();
      });
    }

    self.updateOriginalInput();
    self.refreshItems();
    self.refreshState();
    self.updatePlaceholder();
    self.isSetup = true;

    if ($input.is(&#39;:disabled&#39;)) {
      self.disable();
    }

    self.on(&#39;change&#39;, this.onChange);

    $input.data(&#39;selectize&#39;, self);
    $input.addClass(&#39;selectized&#39;);
    self.trigger(&#39;initialize&#39;);

    // preload options
    if (settings.preload === true) {
      self.onSearchChange(&#39;&#39;);
    }

  },

  /**
     Sets up default rendering functions.
    /
  setupTemplates: function() {
    var self = this;
    var field_label = self.settings.labelField;
    var field_optgroup = self.settings.optgroupLabelField;

    var templates = {
      &#39;optgroup&#39;: function(data) {
        return &#39;&lt;div class=&quot;optgroup&quot;&gt;&#39; + data.html + &#39;&lt;/div&gt;&#39;;
      },
      &#39;optgroup_header&#39;: function(data, escape) {
        return &#39;&lt;div class=&quot;optgroup-header&quot;&gt;&#39; + escape(data[field_optgroup]) + &#39;&lt;/div&gt;&#39;;
      },
      &#39;option&#39;: function(data, escape) {
        return &#39;&lt;div class=&quot;option&quot;&gt;&#39; + escape(data[field_label]) + &#39;&lt;/div&gt;&#39;;
      },
      &#39;item&#39;: function(data, escape) {
        return &#39;&lt;div class=&quot;item&quot;&gt;&#39; + escape(data[field_label]) + &#39;&lt;/div&gt;&#39;;
      },
      &#39;option_create&#39;: function(data, escape) {
        return &#39;&lt;div class=&quot;create&quot;&gt;Add &lt;strong&gt;&#39; + escape(data.input) + &#39;&lt;/strong&gt;&amp;hellip;&lt;/div&gt;&#39;;
      }
    };

    self.settings.render = $.extend({}, templates, self.settings.render);
  },

  /**
     Maps fired events to callbacks provided
     in the settings used when creating the control.
    /
  setupCallbacks: function() {
    var key, fn, callbacks = {
      &#39;initialize&#39;      : &#39;onInitialize&#39;,
      &#39;change&#39;          : &#39;onChange&#39;,
      &#39;item_add&#39;        : &#39;onItemAdd&#39;,
      &#39;item_remove&#39;     : &#39;onItemRemove&#39;,
      &#39;clear&#39;           : &#39;onClear&#39;,
      &#39;option_add&#39;      : &#39;onOptionAdd&#39;,
      &#39;option_remove&#39;   : &#39;onOptionRemove&#39;,
      &#39;option_clear&#39;    : &#39;onOptionClear&#39;,
      &#39;optgroup_add&#39;    : &#39;onOptionGroupAdd&#39;,
      &#39;optgroup_remove&#39; : &#39;onOptionGroupRemove&#39;,
      &#39;optgroup_clear&#39;  : &#39;onOptionGroupClear&#39;,
      &#39;dropdown_open&#39;   : &#39;onDropdownOpen&#39;,
      &#39;dropdown_close&#39;  : &#39;onDropdownClose&#39;,
      &#39;type&#39;            : &#39;onType&#39;,
      &#39;load&#39;            : &#39;onLoad&#39;,
      &#39;focus&#39;           : &#39;onFocus&#39;,
      &#39;blur&#39;            : &#39;onBlur&#39;
    };

    for (key in callbacks) {
      if (callbacks.hasOwnProperty(key)) {
        fn = this.settings[callbacks[key]];
        if (fn) this.on(key, fn);
      }
    }
  },

  /**
     Triggered when the main control element
     has a click event.

     @param {object} e
     @return {boolean}
    /
  onClick: function(e) {
    var self = this;

    // necessary for mobile webkit devices (manual focus triggering
    // is ignored unless invoked within a click event)
    if (!self.isFocused) {
      self.focus();
      e.preventDefault();
    }
  },

  /**
     Triggered when the main control element
     has a mouse down event.

     @param {object} e
     @return {boolean}
    /
  onMouseDown: function(e) {
    var self = this;
    var defaultPrevented = e.isDefaultPrevented();
    var $target = $(e.target);

    if (self.isFocused) {
      // retain focus by preventing native handling. if the
      // event target is the input it should not be modified.
      // otherwise, text selection within the input won&#39;t work.
      if (e.target !== self.$control_input[0]) {
        if (self.settings.mode === &#39;single&#39;) {
          // toggle dropdown
          self.isOpen ? self.close() : self.open();
        } else if (!defaultPrevented) {
          self.setActiveItem(null);
        }
        return false;
      }
    } else {
      // give control focus
      if (!defaultPrevented) {
        window.setTimeout(function() {
          self.focus();
        }, 0);
      }
    }
  },

  /**
     Triggered when the value of the control has been changed.
     This should propagate the event to the original DOM
     input / select element.
    /
  onChange: function() {
    this.$input.trigger(&#39;change&#39;);
  },

  /**
     Triggered on &lt;input&gt; paste.

     @param {object} e
     @returns {boolean}
    /
  onPaste: function(e) {
    var self = this;

    if (self.isFull() || self.isInputHidden || self.isLocked) {
      e.preventDefault();
      return;
    }

    // If a regex or string is included, this will split the pasted
    // input and create Items for each separate value
    if (self.settings.splitOn) {

      // Wait for pasted text to be recognized in value
      setTimeout(function() {
        var pastedText = self.$control_input.val();
        if(!pastedText.match(self.settings.splitOn)){ return }

        var splitInput = $.trim(pastedText).split(self.settings.splitOn);
        for (var i = 0, n = splitInput.length; i &lt; n; i++) {
          self.createItem(splitInput[i]);
        }
      }, 0);
    }
  },

  /**
     Triggered on &lt;input&gt; keypress.

     @param {object} e
     @returns {boolean}
    /
  onKeyPress: function(e) {
    if (this.isLocked) return e &amp;&amp; e.preventDefault();
    var character = String.fromCharCode(e.keyCode || e.which);
    if (this.settings.create &amp;&amp; this.settings.mode === &#39;multi&#39; &amp;&amp; character === this.settings.delimiter) {
      this.createItem();
      e.preventDefault();
      return false;
    }
  },

  /**
     Triggered on &lt;input&gt; keydown.

     @param {object} e
     @returns {boolean}
    /
  onKeyDown: function(e) {
    var isInput = e.target === this.$control_input[0];
    var self = this;

    if (self.isLocked) {
      if (e.keyCode !== KEY_TAB) {
        e.preventDefault();
      }
      return;
    }

    switch (e.keyCode) {
      case KEY_A:
        if (self.isCmdDown) {
          self.selectAll();
          return;
        }
        break;
      case KEY_ESC:
        if (self.isOpen) {
          e.preventDefault();
          e.stopPropagation();
          self.close();
        }
        return;
      case KEY_N:
        if (!e.ctrlKey || e.altKey) break;
      case KEY_DOWN:
        if (!self.isOpen &amp;&amp; self.hasOptions) {
          self.open();
        } else if (self.$activeOption) {
          self.ignoreHover = true;
          var $next = self.getAdjacentOption(self.$activeOption, 1);
          if ($next.length) self.setActiveOption($next, true, true);
        }
        e.preventDefault();
        return;
      case KEY_P:
        if (!e.ctrlKey || e.altKey) break;
      case KEY_UP:
        if (self.$activeOption) {
          self.ignoreHover = true;
          var $prev = self.getAdjacentOption(self.$activeOption, -1);
          if ($prev.length) self.setActiveOption($prev, true, true);
        }
        e.preventDefault();
        return;
      case KEY_RETURN:
        if (self.isOpen &amp;&amp; self.$activeOption) {
          self.onOptionSelect({currentTarget: self.$activeOption});
          e.preventDefault();
        }
        return;
      case KEY_LEFT:
        self.advanceSelection(-1, e);
        return;
      case KEY_RIGHT:
        self.advanceSelection(1, e);
        return;
      case KEY_TAB:
        if (self.settings.selectOnTab &amp;&amp; self.isOpen &amp;&amp; self.$activeOption) {
          self.onOptionSelect({currentTarget: self.$activeOption});

          // Default behaviour is to jump to the next field, we only want this
          // if the current field doesn&#39;t accept any more entries
          if (!self.isFull()) {
            e.preventDefault();
          }
        }
        if (self.settings.create &amp;&amp; self.createItem()) {
          e.preventDefault();
        }
        return;
      case KEY_BACKSPACE:
      case KEY_DELETE:
        self.deleteSelection(e);
        return;
    }

    if ((self.isFull() || self.isInputHidden) &amp;&amp; !(IS_MAC ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      return;
    }
  },

  /**
     Triggered on &lt;input&gt; keyup.

     @param {object} e
     @returns {boolean}
    /
  onKeyUp: function(e) {
    var self = this;

    if (self.isLocked) return e &amp;&amp; e.preventDefault();
    var value = self.$control_input.val() || &#39;&#39;;
    if (self.lastValue !== value) {
      self.lastValue = value;
      self.onSearchChange(value);
      self.refreshOptions();
      self.trigger(&#39;type&#39;, value);
    }
  },

  /**
     Invokes the user-provide option provider / loader.

     Note: this function is debounced in the Selectize
     constructor (by `settings.loadThrottle` milliseconds)

     @param {string} value
    /
  onSearchChange: function(value) {
    var self = this;
    var fn = self.settings.load;
    if (!fn) return;
    if (self.loadedSearches.hasOwnProperty(value)) return;
    self.loadedSearches[value] = true;
    self.load(function(callback) {
      fn.apply(self, [value, callback]);
    });
  },

  /**
     Triggered on &lt;input&gt; focus.

     @param {object} e (optional)
     @returns {boolean}
    /
  onFocus: function(e) {
    var self = this;
    var wasFocused = self.isFocused;

    if (self.isDisabled) {
      self.blur();
      e &amp;&amp; e.preventDefault();
      return false;
    }

    if (self.ignoreFocus) return;
    self.isFocused = true;
    if (self.settings.preload === &#39;focus&#39;) self.onSearchChange(&#39;&#39;);

    if (!wasFocused) self.trigger(&#39;focus&#39;);

    if (!self.$activeItems.length) {
      self.showInput();
      self.setActiveItem(null);
      self.refreshOptions(!!self.settings.openOnFocus);
    }

    self.refreshState();
  },

  /**
     Triggered on &lt;input&gt; blur.

     @param {object} e
     @param {Element} dest
    /
  onBlur: function(e, dest) {
    var self = this;
    if (!self.isFocused) return;
    self.isFocused = false;

    if (self.ignoreFocus) {
      return;
    } else if (!self.ignoreBlur &amp;&amp; document.activeElement === self.$dropdown_content[0]) {
      // necessary to prevent IE closing the dropdown when the scrollbar is clicked
      self.ignoreBlur = true;
      self.onFocus(e);
      return;
    }

    var deactivate = function() {
      self.close();
      self.setTextboxValue(&#39;&#39;);
      self.setActiveItem(null);
      self.setActiveOption(null);
      self.setCaret(self.items.length);
      self.refreshState();

      // IE11 bug: element still marked as active
      dest &amp;&amp; dest.focus &amp;&amp; dest.focus();

      self.ignoreFocus = false;
      self.trigger(&#39;blur&#39;);
    };

    self.ignoreFocus = true;
    if (self.settings.create &amp;&amp; self.settings.createOnBlur) {
      self.createItem(null, false, deactivate);
    } else {
      deactivate();
    }
  },

  /**
     Triggered when the user rolls over
     an option in the autocomplete dropdown menu.

     @param {object} e
     @returns {boolean}
    /
  onOptionHover: function(e) {
    if (this.ignoreHover) return;
    this.setActiveOption(e.currentTarget, false);
  },

  /**
     Triggered when the user clicks on an option
     in the autocomplete dropdown menu.

     @param {object} e
     @returns {boolean}
    /
  onOptionSelect: function(e) {
    var value, $target, $option, self = this;

    if (e.preventDefault) {
      e.preventDefault();
      e.stopPropagation();
    }

    $target = $(e.currentTarget);
    if ($target.hasClass(&#39;create&#39;)) {
      self.createItem(null, function() {
        if (self.settings.closeAfterSelect) {
          self.close();
        }
      });
    } else {
      value = $target.attr(&#39;data-value&#39;);
      if (typeof value !== &#39;undefined&#39;) {
        self.lastQuery = null;
        self.setTextboxValue(&#39;&#39;);
        self.addItem(value);
        if (self.settings.closeAfterSelect) {
          self.close();
        } else if (!self.settings.hideSelected &amp;&amp; e.type &amp;&amp; /mouse/.test(e.type)) {
          self.setActiveOption(self.getOption(value));
        }
      }
    }
  },

  /**
     Triggered when the user clicks on an item
     that has been selected.

     @param {object} e
     @returns {boolean}
    /
  onItemSelect: function(e) {
    var self = this;

    if (self.isLocked) return;
    if (self.settings.mode === &#39;multi&#39;) {
      e.preventDefault();
      self.setActiveItem(e.currentTarget, e);
    }
  },

  /**
     Invokes the provided method that provides
     results to a callback---which are then added
     as options to the control.

     @param {function} fn
    /
  load: function(fn) {
    var self = this;
    var $wrapper = self.$wrapper.addClass(self.settings.loadingClass);

    self.loading++;
    fn.apply(self, [function(results) {
      self.loading = Math.max(self.loading - 1, 0);
      if (results &amp;&amp; results.length) {
        self.addOption(results);
        self.refreshOptions(self.isFocused &amp;&amp; !self.isInputHidden);
      }
      if (!self.loading) {
        $wrapper.removeClass(self.settings.loadingClass);
      }
      self.trigger(&#39;load&#39;, results);
    }]);
  },

  /**
     Sets the input field of the control to the specified value.

     @param {string} value
    /
  setTextboxValue: function(value) {
    var $input = this.$control_input;
    var changed = $input.val() !== value;
    if (changed) {
      $input.val(value).triggerHandler(&#39;update&#39;);
      this.lastValue = value;
    }
  },

  /**
     Returns the value of the control. If multiple items
     can be selected (e.g. &lt;select multiple&gt;), this returns
     an array. If only one item can be selected, this
     returns a string.

     @returns {mixed}
    /
  getValue: function() {
    if (this.tagType === TAG_SELECT &amp;&amp; this.$input.attr(&#39;multiple&#39;)) {
      return this.items;
    } else {
      return this.items.join(this.settings.delimiter);
    }
  },

  /**
     Resets the selected items to the given value.

     @param {mixed} value
    /
  setValue: function(value, silent) {
    var events = silent ? [] : [&#39;change&#39;];

    debounce_events(this, events, function() {
      this.clear(silent);
      this.addItems(value, silent);
    });
  },

  /**
     Sets the selected item.

     @param {object} $item
     @param {object} e (optional)
    /
  setActiveItem: function($item, e) {
    var self = this;
    var eventName;
    var i, idx, begin, end, item, swap;
    var $last;

    if (self.settings.mode === &#39;single&#39;) return;
    $item = $($item);

    // clear the active selection
    if (!$item.length) {
      $(self.$activeItems).removeClass(&#39;active&#39;);
      self.$activeItems = [];
      if (self.isFocused) {
        self.showInput();
      }
      return;
    }

    // modify selection
    eventName = e &amp;&amp; e.type.toLowerCase();

    if (eventName === &#39;mousedown&#39; &amp;&amp; self.isShiftDown &amp;&amp; self.$activeItems.length) {
      $last = self.$control.children(&#39;.active:last&#39;);
      begin = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$last[0]]);
      end   = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$item[0]]);
      if (begin &gt; end) {
        swap  = begin;
        begin = end;
        end   = swap;
      }
      for (i = begin; i &lt;= end; i++) {
        item = self.$control[0].childNodes[i];
        if (self.$activeItems.indexOf(item) === -1) {
          $(item).addClass(&#39;active&#39;);
          self.$activeItems.push(item);
        }
      }
      e.preventDefault();
    } else if ((eventName === &#39;mousedown&#39; &amp;&amp; self.isCtrlDown) || (eventName === &#39;keydown&#39; &amp;&amp; this.isShiftDown)) {
      if ($item.hasClass(&#39;active&#39;)) {
        idx = self.$activeItems.indexOf($item[0]);
        self.$activeItems.splice(idx, 1);
        $item.removeClass(&#39;active&#39;);
      } else {
        self.$activeItems.push($item.addClass(&#39;active&#39;)[0]);
      }
    } else {
      $(self.$activeItems).removeClass(&#39;active&#39;);
      self.$activeItems = [$item.addClass(&#39;active&#39;)[0]];
    }

    // ensure control has focus
    self.hideInput();
    if (!this.isFocused) {
      self.focus();
    }
  },

  /**
     Sets the selected item in the dropdown menu
     of available options.

     @param {object} $object
     @param {boolean} scroll
     @param {boolean} animate
    /
  setActiveOption: function($option, scroll, animate) {
    var height_menu, height_item, y;
    var scroll_top, scroll_bottom;
    var self = this;

    if (self.$activeOption) self.$activeOption.removeClass(&#39;active&#39;);
    self.$activeOption = null;

    $option = $($option);
    if (!$option.length) return;

    self.$activeOption = $option.addClass(&#39;active&#39;);

    if (scroll || !isset(scroll)) {

      height_menu   = self.$dropdown_content.height();
      height_item   = self.$activeOption.outerHeight(true);
      scroll        = self.$dropdown_content.scrollTop() || 0;
      y             = self.$activeOption.offset().top - self.$dropdown_content.offset().top + scroll;
      scroll_top    = y;
      scroll_bottom = y - height_menu + height_item;

      if (y + height_item &gt; height_menu + scroll) {
        self.$dropdown_content.stop().animate({scrollTop: scroll_bottom}, animate ? self.settings.scrollDuration : 0);
      } else if (y &lt; scroll) {
        self.$dropdown_content.stop().animate({scrollTop: scroll_top}, animate ? self.settings.scrollDuration : 0);
      }

    }
  },

  /**
     Selects all items (CTRL + A).
    /
  selectAll: function() {
    var self = this;
    if (self.settings.mode === &#39;single&#39;) return;

    self.$activeItems = Array.prototype.slice.apply(self.$control.children(&#39;:not(input)&#39;).addClass(&#39;active&#39;));
    if (self.$activeItems.length) {
      self.hideInput();
      self.close();
    }
    self.focus();
  },

  /**
     Hides the input element out of view, while
     retaining its focus.
    /
  hideInput: function() {
    var self = this;

    self.setTextboxValue(&#39;&#39;);
    self.$control_input.css({opacity: 0, position: &#39;absolute&#39;, left: self.rtl ? 10000 : -10000});
    self.isInputHidden = true;
  },

  /**
     Restores input visibility.
    /
  showInput: function() {
    this.$control_input.css({opacity: 1, position: &#39;relative&#39;, left: 0});
    this.isInputHidden = false;
  },

  /**
     Gives the control focus.
    /
  focus: function() {
    var self = this;
    if (self.isDisabled) return;

    self.ignoreFocus = true;
    self.$control_input[0].focus();
    window.setTimeout(function() {
      self.ignoreFocus = false;
      self.onFocus();
    }, 0);
  },

  /**
     Forces the control out of focus.

     @param {Element} dest
    /
  blur: function(dest) {
    this.$control_input[0].blur();
    this.onBlur(null, dest);
  },

  /**
     Returns a function that scores an object
     to show how good of a match it is to the
     provided query.

     @param {string} query
     @param {object} options
     @return {function}
    /
  getScoreFunction: function(query) {
    return this.sifter.getScoreFunction(query, this.getSearchOptions());
  },

  /**
     Returns search options for sifter (the system
     for scoring and sorting results).

     @see https://github.com/brianreavis/sifter.js
     @return {object}
    /
  getSearchOptions: function() {
    var settings = this.settings;
    var sort = settings.sortField;
    if (typeof sort === &#39;string&#39;) {
      sort = [{field: sort}];
    }

    return {
      fields      : settings.searchField,
      conjunction : settings.searchConjunction,
      sort        : sort
    };
  },

  /**
     Searches through available options and returns
     a sorted array of matches.

     Returns an object containing:

       - query {string}
       - tokens {array}
       - total {int}
       - items {array}

     @param {string} query
     @returns {object}
    /
  search: function(query) {
    var i, value, score, result, calculateScore;
    var self     = this;
    var settings = self.settings;
    var options  = this.getSearchOptions();

    // validate user-provided result scoring function
    if (settings.score) {
      calculateScore = self.settings.score.apply(this, [query]);
      if (typeof calculateScore !== &#39;function&#39;) {
        throw new Error(&#39;Selectize &quot;score&quot; setting must be a function that returns a function&#39;);
      }
    }

    // perform search
    if (query !== self.lastQuery) {
      self.lastQuery = query;
      result = self.sifter.search(query, $.extend(options, {score: calculateScore}));
      self.currentResults = result;
    } else {
      result = $.extend(true, {}, self.currentResults);
    }

    // filter out selected items
    if (settings.hideSelected) {
      for (i = result.items.length - 1; i &gt;= 0; i--) {
        if (self.items.indexOf(hash_key(result.items[i].id)) !== -1) {
          result.items.splice(i, 1);
        }
      }
    }

    return result;
  },

  /**
     Refreshes the list of available options shown
     in the autocomplete dropdown menu.

     @param {boolean} triggerDropdown
    /
  refreshOptions: function(triggerDropdown) {
    var i, j, k, n, groups, groups_order, option, option_html, optgroup, optgroups, html, html_children, has_create_option;
    var $active, $active_before, $create;

    if (typeof triggerDropdown === &#39;undefined&#39;) {
      triggerDropdown = true;
    }

    var self              = this;
    var query             = $.trim(self.$control_input.val());
    var results           = self.search(query);
    var $dropdown_content = self.$dropdown_content;
    var active_before     = self.$activeOption &amp;&amp; hash_key(self.$activeOption.attr(&#39;data-value&#39;));

    // build markup
    n = results.items.length;
    if (typeof self.settings.maxOptions === &#39;number&#39;) {
      n = Math.min(n, self.settings.maxOptions);
    }

    // render and group available options individually
    groups = {};
    groups_order = [];

    for (i = 0; i &lt; n; i++) {
      option      = self.options[results.items[i].id];
      option_html = self.render(&#39;option&#39;, option);
      optgroup    = option[self.settings.optgroupField] || &#39;&#39;;
      optgroups   = $.isArray(optgroup) ? optgroup : [optgroup];

      for (j = 0, k = optgroups &amp;&amp; optgroups.length; j &lt; k; j++) {
        optgroup = optgroups[j];
        if (!self.optgroups.hasOwnProperty(optgroup)) {
          optgroup = &#39;&#39;;
        }
        if (!groups.hasOwnProperty(optgroup)) {
          groups[optgroup] = document.createDocumentFragment();
          groups_order.push(optgroup);
        }
        groups[optgroup].appendChild(option_html);
      }
    }

    // sort optgroups
    if (this.settings.lockOptgroupOrder) {
      groups_order.sort(function(a, b) {
        var a_order = self.optgroups[a].$order || 0;
        var b_order = self.optgroups[b].$order || 0;
        return a_order - b_order;
      });
    }

    // render optgroup headers &amp; join groups
    html = document.createDocumentFragment();
    for (i = 0, n = groups_order.length; i &lt; n; i++) {
      optgroup = groups_order[i];
      if (self.optgroups.hasOwnProperty(optgroup) &amp;&amp; groups[optgroup].childNodes.length) {
        // render the optgroup header and options within it,
        // then pass it to the wrapper template
        html_children = document.createDocumentFragment();
        html_children.appendChild(self.render(&#39;optgroup_header&#39;, self.optgroups[optgroup]));
        html_children.appendChild(groups[optgroup]);

        html.appendChild(self.render(&#39;optgroup&#39;, $.extend({}, self.optgroups[optgroup], {
          html: domToString(html_children),
          dom:  html_children
        })));
      } else {
        html.appendChild(groups[optgroup]);
      }
    }

    $dropdown_content.html(html);

    // highlight matching terms inline
    if (self.settings.highlight &amp;&amp; results.query.length &amp;&amp; results.tokens.length) {
      $dropdown_content.removeHighlight();
      for (i = 0, n = results.tokens.length; i &lt; n; i++) {
        highlight($dropdown_content, results.tokens[i].regex);
      }
    }

    // add &quot;selected&quot; class to selected options
    if (!self.settings.hideSelected) {
      for (i = 0, n = self.items.length; i &lt; n; i++) {
        self.getOption(self.items[i]).addClass(&#39;selected&#39;);
      }
    }

    // add create option
    has_create_option = self.canCreate(query);
    if (has_create_option) {
      $dropdown_content.prepend(self.render(&#39;option_create&#39;, {input: query}));
      $create = $($dropdown_content[0].childNodes[0]);
    }

    // activate
    self.hasOptions = results.items.length &gt; 0 || has_create_option;
    if (self.hasOptions) {
      if (results.items.length &gt; 0) {
        $active_before = active_before &amp;&amp; self.getOption(active_before);
        if ($active_before &amp;&amp; $active_before.length) {
          $active = $active_before;
        } else if (self.settings.mode === &#39;single&#39; &amp;&amp; self.items.length) {
          $active = self.getOption(self.items[0]);
        }
        if (!$active || !$active.length) {
          if ($create &amp;&amp; !self.settings.addPrecedence) {
            $active = self.getAdjacentOption($create, 1);
          } else {
            $active = $dropdown_content.find(&#39;[data-selectable]:first&#39;);
          }
        }
      } else {
        $active = $create;
      }
      self.setActiveOption($active);
      if (triggerDropdown &amp;&amp; !self.isOpen) { self.open(); }
    } else {
      self.setActiveOption(null);
      if (triggerDropdown &amp;&amp; self.isOpen) { self.close(); }
    }
  },

  /**
     Adds an available option. If it already exists,
     nothing will happen. Note: this does not refresh
     the options list dropdown (use `refreshOptions`
     for that).

     Usage:

       this.addOption(data)

     @param {object|array} data
    /
  addOption: function(data) {
    var i, n, value, self = this;

    if ($.isArray(data)) {
      for (i = 0, n = data.length; i &lt; n; i++) {
        self.addOption(data[i]);
      }
      return;
    }

    if (value = self.registerOption(data)) {
      self.userOptions[value] = true;
      self.lastQuery = null;
      self.trigger(&#39;option_add&#39;, value, data);
    }
  },

  /**
     Registers an option to the pool of options.

     @param {object} data
     @return {boolean|string}
    /
  registerOption: function(data) {
    var key = hash_key(data[this.settings.valueField]);
    if (typeof key === &#39;undefined&#39; || key === null || this.options.hasOwnProperty(key)) return false;
    data.$order = data.$order || ++this.order;
    this.options[key] = data;
    return key;
  },

  /**
     Registers an option group to the pool of option groups.

     @param {object} data
     @return {boolean|string}
    /
  registerOptionGroup: function(data) {
    var key = hash_key(data[this.settings.optgroupValueField]);
    if (!key) return false;

    data.$order = data.$order || ++this.order;
    this.optgroups[key] = data;
    return key;
  },

  /**
     Registers a new optgroup for options
     to be bucketed into.

     @param {string} id
     @param {object} data
    /
  addOptionGroup: function(id, data) {
    data[this.settings.optgroupValueField] = id;
    if (id = this.registerOptionGroup(data)) {
      this.trigger(&#39;optgroup_add&#39;, id, data);
    }
  },

  /**
     Removes an existing option group.

     @param {string} id
    /
  removeOptionGroup: function(id) {
    if (this.optgroups.hasOwnProperty(id)) {
      delete this.optgroups[id];
      this.renderCache = {};
      this.trigger(&#39;optgroup_remove&#39;, id);
    }
  },

  /**
     Clears all existing option groups.
    /
  clearOptionGroups: function() {
    this.optgroups = {};
    this.renderCache = {};
    this.trigger(&#39;optgroup_clear&#39;);
  },

  /**
     Updates an option available for selection. If
     it is visible in the selected items or options
     dropdown, it will be re-rendered automatically.

     @param {string} value
     @param {object} data
    /
  updateOption: function(value, data) {
    var self = this;
    var $item, $item_new;
    var value_new, index_item, cache_items, cache_options, order_old;

    value     = hash_key(value);
    value_new = hash_key(data[self.settings.valueField]);

    // sanity checks
    if (value === null) return;
    if (!self.options.hasOwnProperty(value)) return;
    if (typeof value_new !== &#39;string&#39;) throw new Error(&#39;Value must be set in option data&#39;);

    order_old = self.options[value].$order;

    // update references
    if (value_new !== value) {
      delete self.options[value];
      index_item = self.items.indexOf(value);
      if (index_item !== -1) {
        self.items.splice(index_item, 1, value_new);
      }
    }
    data.$order = data.$order || order_old;
    self.options[value_new] = data;

    // invalidate render cache
    cache_items = self.renderCache[&#39;item&#39;];
    cache_options = self.renderCache[&#39;option&#39;];

    if (cache_items) {
      delete cache_items[value];
      delete cache_items[value_new];
    }
    if (cache_options) {
      delete cache_options[value];
      delete cache_options[value_new];
    }

    // update the item if it&#39;s selected
    if (self.items.indexOf(value_new) !== -1) {
      $item = self.getItem(value);
      $item_new = $(self.render(&#39;item&#39;, data));
      if ($item.hasClass(&#39;active&#39;)) $item_new.addClass(&#39;active&#39;);
      $item.replaceWith($item_new);
    }

    // invalidate last query because we might have updated the sortField
    self.lastQuery = null;

    // update dropdown contents
    if (self.isOpen) {
      self.refreshOptions(false);
    }
  },

  /**
     Removes a single option.

     @param {string} value
     @param {boolean} silent
    /
  removeOption: function(value, silent) {
    var self = this;
    value = hash_key(value);

    var cache_items = self.renderCache[&#39;item&#39;];
    var cache_options = self.renderCache[&#39;option&#39;];
    if (cache_items) delete cache_items[value];
    if (cache_options) delete cache_options[value];

    delete self.userOptions[value];
    delete self.options[value];
    self.lastQuery = null;
    self.trigger(&#39;option_remove&#39;, value);
    self.removeItem(value, silent);
  },

  /**
     Clears all options.
    /
  clearOptions: function() {
    var self = this;

    self.loadedSearches = {};
    self.userOptions = {};
    self.renderCache = {};
    self.options = self.sifter.items = {};
    self.lastQuery = null;
    self.trigger(&#39;option_clear&#39;);
    self.clear();
  },

  /**
     Returns the jQuery element of the option
     matching the given value.

     @param {string} value
     @returns {object}
    /
  getOption: function(value) {
    return this.getElementWithValue(value, this.$dropdown_content.find(&#39;[data-selectable]&#39;));
  },

  /**
     Returns the jQuery element of the next or
     previous selectable option.

     @param {object} $option
     @param {int} direction  can be 1 for next or -1 for previous
     @return {object}
    /
  getAdjacentOption: function($option, direction) {
    var $options = this.$dropdown.find(&#39;[data-selectable]&#39;);
    var index    = $options.index($option) + direction;

    return index &gt;= 0 &amp;&amp; index &lt; $options.length ? $options.eq(index) : $();
  },

  /**
     Finds the first element with a &quot;data-value&quot; attribute
     that matches the given value.

     @param {mixed} value
     @param {object} $els
     @return {object}
    /
  getElementWithValue: function(value, $els) {
    value = hash_key(value);

    if (typeof value !== &#39;undefined&#39; &amp;&amp; value !== null) {
      for (var i = 0, n = $els.length; i &lt; n; i++) {
        if ($els[i].getAttribute(&#39;data-value&#39;) === value) {
          return $($els[i]);
        }
      }
    }

    return $();
  },

  /**
     Returns the jQuery element of the item
     matching the given value.

     @param {string} value
     @returns {object}
    /
  getItem: function(value) {
    return this.getElementWithValue(value, this.$control.children());
  },

  /**
     &quot;Selects&quot; multiple items at once. Adds them to the list
     at the current caret position.

     @param {string} value
     @param {boolean} silent
    /
  addItems: function(values, silent) {
    var items = $.isArray(values) ? values : [values];
    for (var i = 0, n = items.length; i &lt; n; i++) {
      this.isPending = (i &lt; n - 1);
      this.addItem(items[i], silent);
    }
  },

  /**
     &quot;Selects&quot; an item. Adds it to the list
     at the current caret position.

     @param {string} value
     @param {boolean} silent
    /
  addItem: function(value, silent) {
    var events = silent ? [] : [&#39;change&#39;];

    debounce_events(this, events, function() {
      var $item, $option, $options;
      var self = this;
      var inputMode = self.settings.mode;
      var i, active, value_next, wasFull;
      value = hash_key(value);

      if (self.items.indexOf(value) !== -1) {
        if (inputMode === &#39;single&#39;) self.close();
        return;
      }

      if (!self.options.hasOwnProperty(value)) return;
      if (inputMode === &#39;single&#39;) self.clear(silent);
      if (inputMode === &#39;multi&#39; &amp;&amp; self.isFull()) return;

      $item = $(self.render(&#39;item&#39;, self.options[value]));
      wasFull = self.isFull();
      self.items.splice(self.caretPos, 0, value);
      self.insertAtCaret($item);
      if (!self.isPending || (!wasFull &amp;&amp; self.isFull())) {
        self.refreshState();
      }

      if (self.isSetup) {
        $options = self.$dropdown_content.find(&#39;[data-selectable]&#39;);

        // update menu / remove the option (if this is not one item being added as part of series)
        if (!self.isPending) {
          $option = self.getOption(value);
          value_next = self.getAdjacentOption($option, 1).attr(&#39;data-value&#39;);
          self.refreshOptions(self.isFocused &amp;&amp; inputMode !== &#39;single&#39;);
          if (value_next) {
            self.setActiveOption(self.getOption(value_next));
          }
        }

        // hide the menu if the maximum number of items have been selected or no options are left
        if (!$options.length || self.isFull()) {
          self.close();
        } else {
          self.positionDropdown();
        }

        self.updatePlaceholder();
        self.trigger(&#39;item_add&#39;, value, $item);
        self.updateOriginalInput({silent: silent});
      }
    });
  },

  /**
     Removes the selected item matching
     the provided value.

     @param {string} value
    /
  removeItem: function(value, silent) {
    var self = this;
    var $item, i, idx;

    $item = (value instanceof $) ? value : self.getItem(value);
    value = hash_key($item.attr(&#39;data-value&#39;));
    i = self.items.indexOf(value);

    if (i !== -1) {
      $item.remove();
      if ($item.hasClass(&#39;active&#39;)) {
        idx = self.$activeItems.indexOf($item[0]);
        self.$activeItems.splice(idx, 1);
      }

      self.items.splice(i, 1);
      self.lastQuery = null;
      if (!self.settings.persist &amp;&amp; self.userOptions.hasOwnProperty(value)) {
        self.removeOption(value, silent);
      }

      if (i &lt; self.caretPos) {
        self.setCaret(self.caretPos - 1);
      }

      self.refreshState();
      self.updatePlaceholder();
      self.updateOriginalInput({silent: silent});
      self.positionDropdown();
      self.trigger(&#39;item_remove&#39;, value, $item);
    }
  },

  /**
     Invokes the `create` method provided in the
     selectize options that should provide the data
     for the new item, given the user input.

     Once this completes, it will be added
     to the item list.

     @param {string} value
     @param {boolean} [triggerDropdown]
     @param {function} [callback]
     @return {boolean}
    /
  createItem: function(input, triggerDropdown) {
    var self  = this;
    var caret = self.caretPos;
    input = input || $.trim(self.$control_input.val() || &#39;&#39;);

    var callback = arguments[arguments.length - 1];
    if (typeof callback !== &#39;function&#39;) callback = function() {};

    if (typeof triggerDropdown !== &#39;boolean&#39;) {
      triggerDropdown = true;
    }

    if (!self.canCreate(input)) {
      callback();
      return false;
    }

    self.lock();

    var setup = (typeof self.settings.create === &#39;function&#39;) ? this.settings.create : function(input) {
      var data = {};
      data[self.settings.labelField] = input;
      data[self.settings.valueField] = input;
      return data;
    };

    var create = once(function(data) {
      self.unlock();

      if (!data || typeof data !== &#39;object&#39;) return callback();
      var value = hash_key(data[self.settings.valueField]);
      if (typeof value !== &#39;string&#39;) return callback();

      self.setTextboxValue(&#39;&#39;);
      self.addOption(data);
      self.setCaret(caret);
      self.addItem(value);
      self.refreshOptions(triggerDropdown &amp;&amp; self.settings.mode !== &#39;single&#39;);
      callback(data);
    });

    var output = setup.apply(this, [input, create]);
    if (typeof output !== &#39;undefined&#39;) {
      create(output);
    }

    return true;
  },

  /**
     Re-renders the selected item lists.
    /
  refreshItems: function() {
    this.lastQuery = null;

    if (this.isSetup) {
      this.addItem(this.items);
    }

    this.refreshState();
    this.updateOriginalInput();
  },

  /**
     Updates all state-dependent attributes
     and CSS classes.
    /
  refreshState: function() {
    this.refreshValidityState();
    this.refreshClasses();
  },

  /**
     Update the `required` attribute of both input and control input.

     The `required` property needs to be activated on the control input
     for the error to be displayed at the right place. `required` also
     needs to be temporarily deactivated on the input since the input is
     hidden and can&#39;t show errors.
    /
  refreshValidityState: function() {
    if (!this.isRequired) return false;

    var invalid = !this.items.length;

    this.isInvalid = invalid;
    this.$control_input.prop(&#39;required&#39;, invalid);
    this.$input.prop(&#39;required&#39;, !invalid);
  },

  /**
     Updates all state-dependent CSS classes.
    /
  refreshClasses: function() {
    var self     = this;
    var isFull   = self.isFull();
    var isLocked = self.isLocked;

    self.$wrapper
      .toggleClass(&#39;rtl&#39;, self.rtl);

    self.$control
      .toggleClass(&#39;focus&#39;, self.isFocused)
      .toggleClass(&#39;disabled&#39;, self.isDisabled)
      .toggleClass(&#39;required&#39;, self.isRequired)
      .toggleClass(&#39;invalid&#39;, self.isInvalid)
      .toggleClass(&#39;locked&#39;, isLocked)
      .toggleClass(&#39;full&#39;, isFull).toggleClass(&#39;not-full&#39;, !isFull)
      .toggleClass(&#39;input-active&#39;, self.isFocused &amp;&amp; !self.isInputHidden)
      .toggleClass(&#39;dropdown-active&#39;, self.isOpen)
      .toggleClass(&#39;has-options&#39;, !$.isEmptyObject(self.options))
      .toggleClass(&#39;has-items&#39;, self.items.length &gt; 0);

    self.$control_input.data(&#39;grow&#39;, !isFull &amp;&amp; !isLocked);
  },

  /**
     Determines whether or not more items can be added
     to the control without exceeding the user-defined maximum.

     @returns {boolean}
    /
  isFull: function() {
    return this.settings.maxItems !== null &amp;&amp; this.items.length &gt;= this.settings.maxItems;
  },

  /**
     Refreshes the original &lt;select&gt; or &lt;input&gt;
     element to reflect the current state.
    /
  updateOriginalInput: function(opts) {
    var i, n, options, label, self = this;
    opts = opts || {};

    if (self.tagType === TAG_SELECT) {
      options = [];
      for (i = 0, n = self.items.length; i &lt; n; i++) {
        label = self.options[self.items[i]][self.settings.labelField] || &#39;&#39;;
        options.push(&#39;&lt;option value=&quot;&#39; + escape_html(self.items[i]) + &#39;&quot; selected=&quot;selected&quot;&gt;&#39; + escape_html(label) + &#39;&lt;/option&gt;&#39;);
      }
      if (!options.length &amp;&amp; !this.$input.attr(&#39;multiple&#39;)) {
        options.push(&#39;&lt;option value=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt;&#39;);
      }
      self.$input.html(options.join(&#39;&#39;));
    } else {
      self.$input.val(self.getValue());
      self.$input.attr(&#39;value&#39;,self.$input.val());
    }

    if (self.isSetup) {
      if (!opts.silent) {
        self.trigger(&#39;change&#39;, self.$input.val());
      }
    }
  },

  /**
     Shows/hide the input placeholder depending
     on if there items in the list already.
    /
  updatePlaceholder: function() {
    if (!this.settings.placeholder) return;
    var $input = this.$control_input;

    if (this.items.length) {
      $input.removeAttr(&#39;placeholder&#39;);
    } else {
      $input.attr(&#39;placeholder&#39;, this.settings.placeholder);
    }
    $input.triggerHandler(&#39;update&#39;, {force: true});
  },

  /**
     Shows the autocomplete dropdown containing
     the available options.
    /
  open: function() {
    var self = this;

    if (self.isLocked || self.isOpen || (self.settings.mode === &#39;multi&#39; &amp;&amp; self.isFull())) return;
    self.focus();
    self.isOpen = true;
    self.refreshState();
    self.$dropdown.css({visibility: &#39;hidden&#39;, display: &#39;block&#39;});
    self.positionDropdown();
    self.$dropdown.css({visibility: &#39;visible&#39;});
    self.trigger(&#39;dropdown_open&#39;, self.$dropdown);
  },

  /**
     Closes the autocomplete dropdown menu.
    /
  close: function() {
    var self = this;
    var trigger = self.isOpen;

    if (self.settings.mode === &#39;single&#39; &amp;&amp; self.items.length) {
      self.hideInput();
      self.$control_input.blur(); // close keyboard on iOS
    }

    self.isOpen = false;
    self.$dropdown.hide();
    self.setActiveOption(null);
    self.refreshState();

    if (trigger) self.trigger(&#39;dropdown_close&#39;, self.$dropdown);
  },

  /**
     Calculates and applies the appropriate
     position of the dropdown.
    /
  positionDropdown: function() {
    var $control = this.$control;
    var offset = this.settings.dropdownParent === &#39;body&#39; ? $control.offset() : $control.position();
    offset.top += $control.outerHeight(true);

    this.$dropdown.css({
      width : $control.outerWidth(),
      top   : offset.top,
      left  : offset.left
    });
  },

  /**
     Resets / clears all selected items
     from the control.

     @param {boolean} silent
    /
  clear: function(silent) {
    var self = this;

    if (!self.items.length) return;
    self.$control.children(&#39;:not(input)&#39;).remove();
    self.items = [];
    self.lastQuery = null;
    self.setCaret(0);
    self.setActiveItem(null);
    self.updatePlaceholder();
    self.updateOriginalInput({silent: silent});
    self.refreshState();
    self.showInput();
    self.trigger(&#39;clear&#39;);
  },

  /**
     A helper method for inserting an element
     at the current caret position.

     @param {object} $el
    /
  insertAtCaret: function($el) {
    var caret = Math.min(this.caretPos, this.items.length);
    if (caret === 0) {
      this.$control.prepend($el);
    } else {
      $(this.$control[0].childNodes[caret]).before($el);
    }
    this.setCaret(caret + 1);
  },

  /**
     Removes the current selected item(s).

     @param {object} e (optional)
     @returns {boolean}
    /
  deleteSelection: function(e) {
    var i, n, direction, selection, values, caret, option_select, $option_select, $tail;
    var self = this;

    direction = (e &amp;&amp; e.keyCode === KEY_BACKSPACE) ? -1 : 1;
    selection = getSelection(self.$control_input[0]);

    if (self.$activeOption &amp;&amp; !self.settings.hideSelected) {
      option_select = self.getAdjacentOption(self.$activeOption, -1).attr(&#39;data-value&#39;);
    }

    // determine items that will be removed
    values = [];

    if (self.$activeItems.length) {
      $tail = self.$control.children(&#39;.active:&#39; + (direction &gt; 0 ? &#39;last&#39; : &#39;first&#39;));
      caret = self.$control.children(&#39;:not(input)&#39;).index($tail);
      if (direction &gt; 0) { caret++; }

      for (i = 0, n = self.$activeItems.length; i &lt; n; i++) {
        values.push($(self.$activeItems[i]).attr(&#39;data-value&#39;));
      }
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
    } else if ((self.isFocused || self.settings.mode === &#39;single&#39;) &amp;&amp; self.items.length) {
      if (direction &lt; 0 &amp;&amp; selection.start === 0 &amp;&amp; selection.length === 0) {
        values.push(self.items[self.caretPos - 1]);
      } else if (direction &gt; 0 &amp;&amp; selection.start === self.$control_input.val().length) {
        values.push(self.items[self.caretPos]);
      }
    }

    // allow the callback to abort
    if (!values.length || (typeof self.settings.onDelete === &#39;function&#39; &amp;&amp; self.settings.onDelete.apply(self, [values]) === false)) {
      return false;
    }

    // perform removal
    if (typeof caret !== &#39;undefined&#39;) {
      self.setCaret(caret);
    }
    while (values.length) {
      self.removeItem(values.pop());
    }

    self.showInput();
    self.positionDropdown();
    self.refreshOptions(true);

    // select previous option
    if (option_select) {
      $option_select = self.getOption(option_select);
      if ($option_select.length) {
        self.setActiveOption($option_select);
      }
    }

    return true;
  },

  /**
     Selects the previous / next item (depending
     on the `direction` argument).

     &gt; 0 - right
     &lt; 0 - left

     @param {int} direction
     @param {object} e (optional)
    /
  advanceSelection: function(direction, e) {
    var tail, selection, idx, valueLength, cursorAtEdge, $tail;
    var self = this;

    if (direction === 0) return;
    if (self.rtl) direction *= -1;

    tail = direction &gt; 0 ? &#39;last&#39; : &#39;first&#39;;
    selection = getSelection(self.$control_input[0]);

    if (self.isFocused &amp;&amp; !self.isInputHidden) {
      valueLength = self.$control_input.val().length;
      cursorAtEdge = direction &lt; 0
        ? selection.start === 0 &amp;&amp; selection.length === 0
        : selection.start === valueLength;

      if (cursorAtEdge &amp;&amp; !valueLength) {
        self.advanceCaret(direction, e);
      }
    } else {
      $tail = self.$control.children(&#39;.active:&#39; + tail);
      if ($tail.length) {
        idx = self.$control.children(&#39;:not(input)&#39;).index($tail);
        self.setActiveItem(null);
        self.setCaret(direction &gt; 0 ? idx + 1 : idx);
      }
    }
  },

  /**
     Moves the caret left / right.

     @param {int} direction
     @param {object} e (optional)
    /
  advanceCaret: function(direction, e) {
    var self = this, fn, $adj;

    if (direction === 0) return;

    fn = direction &gt; 0 ? &#39;next&#39; : &#39;prev&#39;;
    if (self.isShiftDown) {
      $adj = self.$control_input[fn]();
      if ($adj.length) {
        self.hideInput();
        self.setActiveItem($adj);
        e &amp;&amp; e.preventDefault();
      }
    } else {
      self.setCaret(self.caretPos + direction);
    }
  },

  /**
     Moves the caret to the specified index.

     @param {int} i
    /
  setCaret: function(i) {
    var self = this;

    if (self.settings.mode === &#39;single&#39;) {
      i = self.items.length;
    } else {
      i = Math.max(0, Math.min(self.items.length, i));
    }

    if(!self.isPending) {
      // the input must be moved by leaving it in place and moving the
      // siblings, due to the fact that focus cannot be restored once lost
      // on mobile webkit devices
      var j, n, fn, $children, $child;
      $children = self.$control.children(&#39;:not(input)&#39;);
      for (j = 0, n = $children.length; j &lt; n; j++) {
        $child = $($children[j]).detach();
        if (j &lt;  i) {
          self.$control_input.before($child);
        } else {
          self.$control.append($child);
        }
      }
    }

    self.caretPos = i;
  },

  /**
     Disables user input on the control. Used while
     items are being asynchronously created.
    /
  lock: function() {
    this.close();
    this.isLocked = true;
    this.refreshState();
  },

  /**
     Re-enables user input on the control.
    /
  unlock: function() {
    this.isLocked = false;
    this.refreshState();
  },

  /**
     Disables user input on the control completely.
     While disabled, it cannot receive focus.
    /
  disable: function() {
    var self = this;
    self.$input.prop(&#39;disabled&#39;, true);
    self.$control_input.prop(&#39;disabled&#39;, true).prop(&#39;tabindex&#39;, -1);
    self.isDisabled = true;
    self.lock();
  },

  /**
     Enables the control so that it can respond
     to focus and user input.
    /
  enable: function() {
    var self = this;
    self.$input.prop(&#39;disabled&#39;, false);
    self.$control_input.prop(&#39;disabled&#39;, false).prop(&#39;tabindex&#39;, self.tabIndex);
    self.isDisabled = false;
    self.unlock();
  },

  /**
     Completely destroys the control and
     unbinds all event listeners so that it can
     be garbage collected.
    /
  destroy: function() {
    var self = this;
    var eventNS = self.eventNS;
    var revertSettings = self.revertSettings;

    self.trigger(&#39;destroy&#39;);
    self.off();
    self.$wrapper.remove();
    self.$dropdown.remove();

    self.$input
      .html(&#39;&#39;)
      .append(revertSettings.$children)
      .removeAttr(&#39;tabindex&#39;)
      .removeClass(&#39;selectized&#39;)
      .attr({tabindex: revertSettings.tabindex})
      .show();

    self.$control_input.removeData(&#39;grow&#39;);
    self.$input.removeData(&#39;selectize&#39;);

    $(window).off(eventNS);
    $(document).off(eventNS);
    $(document.body).off(eventNS);

    delete self.$input[0].selectize;
  },

  /**
     A helper method for rendering &quot;item&quot; and
     &quot;option&quot; templates, given the data.

     @param {string} templateName
     @param {object} data
     @returns {string}
    /
  render: function(templateName, data) {
    var value, id, label;
    var html = &#39;&#39;;
    var cache = false;
    var self = this;
    var regex_tag = /^[\t \r\n]*&lt;([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;

    if (templateName === &#39;option&#39; || templateName === &#39;item&#39;) {
      value = hash_key(data[self.settings.valueField]);
      cache = !!value;
    }

    // pull markup from cache if it exists
    if (cache) {
      if (!isset(self.renderCache[templateName])) {
        self.renderCache[templateName] = {};
      }
      if (self.renderCache[templateName].hasOwnProperty(value)) {
        return self.renderCache[templateName][value];
      }
    }

    // render markup
    html = $(self.settings.render[templateName].apply(this, [data, escape_html]));

    // add mandatory attributes
    if (templateName === &#39;option&#39; || templateName === &#39;option_create&#39;) {
      html.attr(&#39;data-selectable&#39;, &#39;&#39;);
    }
    else if (templateName === &#39;optgroup&#39;) {
      id = data[self.settings.optgroupValueField] || &#39;&#39;;
      html.attr(&#39;data-group&#39;, id);
    }
    if (templateName === &#39;option&#39; || templateName === &#39;item&#39;) {
      html.attr(&#39;data-value&#39;, value || &#39;&#39;);
    }

    // update cache
    if (cache) {
      self.renderCache[templateName][value] = html[0];
    }

    return html[0];
  },

  /**
     Clears the render cache for a template. If
     no template is given, clears all render
     caches.

     @param {string} templateName
    /
  clearCache: function(templateName) {
    var self = this;
    if (typeof templateName === &#39;undefined&#39;) {
      self.renderCache = {};
    } else {
      delete self.renderCache[templateName];
    }
  },

  /**
     Determines whether or not to display the
     create item prompt, given a user input.

     @param {string} input
     @return {boolean}
    /
  canCreate: function(input) {
    var self = this;
    if (!self.settings.create) return false;
    var filter = self.settings.createFilter;
    return input.length
      &amp;&amp; (typeof filter !== &#39;function&#39; || filter.apply(self, [input]))
      &amp;&amp; (typeof filter !== &#39;string&#39; || new RegExp(filter).test(input))
      &amp;&amp; (!(filter instanceof RegExp) || filter.test(input));
  }

});

Selectize.count = 0;
Selectize.defaults = {
  options: [],
  optgroups: [],

  plugins: [],
  delimiter: &#39;,&#39;,
  splitOn: null, // regexp or string for splitting up values from a paste command
  persist: true,
  diacritics: true,
  create: false,
  createOnBlur: false,
  createFilter: null,
  highlight: true,
  openOnFocus: true,
  maxOptions: 1000,
  maxItems: null,
  hideSelected: null,
  addPrecedence: false,
  selectOnTab: false,
  preload: false,
  allowEmptyOption: false,
  closeAfterSelect: false,

  scrollDuration: 60,
  loadThrottle: 300,
  loadingClass: &#39;loading&#39;,

  dataAttr: &#39;data-data&#39;,
  optgroupField: &#39;optgroup&#39;,
  valueField: &#39;value&#39;,
  labelField: &#39;text&#39;,
  optgroupLabelField: &#39;label&#39;,
  optgroupValueField: &#39;value&#39;,
  lockOptgroupOrder: false,

  sortField: &#39;$order&#39;,
  searchField: [&#39;text&#39;],
  searchConjunction: &#39;and&#39;,

  mode: null,
  wrapperClass: &#39;selectize-control&#39;,
  inputClass: &#39;selectize-input&#39;,
  dropdownClass: &#39;selectize-dropdown&#39;,
  dropdownContentClass: &#39;selectize-dropdown-content&#39;,

  dropdownParent: null,

  copyClassesToDropdown: true,

  /*
  load                 : null, // function(query, callback) { ... }
  score                : null, // function(search) { ... }
  onInitialize         : null, // function() { ... }
  onChange             : null, // function(value) { ... }
  onItemAdd            : null, // function(value, $item) { ... }
  onItemRemove         : null, // function(value) { ... }
  onClear              : null, // function() { ... }
  onOptionAdd          : null, // function(value, data) { ... }
  onOptionRemove       : null, // function(value) { ... }
  onOptionClear        : null, // function() { ... }
  onOptionGroupAdd     : null, // function(id, data) { ... }
  onOptionGroupRemove  : null, // function(id) { ... }
  onOptionGroupClear   : null, // function() { ... }
  onDropdownOpen       : null, // function($dropdown) { ... }
  onDropdownClose      : null, // function($dropdown) { ... }
  onType               : null, // function(str) { ... }
  onDelete             : null, // function(values) { ... }
   /

  render: {
    /*
    item: null,
    optgroup: null,
    optgroup_header: null,
    option: null,
    option_create: null
     /
  }
};

$.fn.selectize = function(settings_user) {
  var defaults             = $.fn.selectize.defaults;
  var settings             = $.extend({}, defaults, settings_user);
  var attr_data            = settings.dataAttr;
  var field_label          = settings.labelField;
  var field_value          = settings.valueField;
  var field_optgroup       = settings.optgroupField;
  var field_optgroup_label = settings.optgroupLabelField;
  var field_optgroup_value = settings.optgroupValueField;

  /**
     Initializes selectize from a &lt;input type=&quot;text&quot;&gt; element.

     @param {object} $input
     @param {object} settings_element
    /
  var init_textbox = function($input, settings_element) {
    var i, n, values, option;

    var data_raw = $input.attr(attr_data);

    if (!data_raw) {
      var value = $.trim($input.val() || &#39;&#39;);
      if (!settings.allowEmptyOption &amp;&amp; !value.length) return;
      values = value.split(settings.delimiter);
      for (i = 0, n = values.length; i &lt; n; i++) {
        option = {};
        option[field_label] = values[i];
        option[field_value] = values[i];
        settings_element.options.push(option);
      }
      settings_element.items = values;
    } else {
      settings_element.options = JSON.parse(data_raw);
      for (i = 0, n = settings_element.options.length; i &lt; n; i++) {
        settings_element.items.push(settings_element.options[i][field_value]);
      }
    }
  };

  /**
     Initializes selectize from a &lt;select&gt; element.

     @param {object} $input
     @param {object} settings_element
    /
  var init_select = function($input, settings_element) {
    var i, n, tagName, $children, order = 0;
    var options = settings_element.options;
    var optionsMap = {};

    var readData = function($el) {
      var data = attr_data &amp;&amp; $el.attr(attr_data);
      if (typeof data === &#39;string&#39; &amp;&amp; data.length) {
        return JSON.parse(data);
      }
      return null;
    };

    var addOption = function($option, group) {
      $option = $($option);

      var value = hash_key($option.val());
      if (!value &amp;&amp; !settings.allowEmptyOption) return;

      // if the option already exists, it&#39;s probably been
      // duplicated in another optgroup. in this case, push
      // the current group to the &quot;optgroup&quot; property on the
      // existing option so that it&#39;s rendered in both places.
      if (optionsMap.hasOwnProperty(value)) {
        if (group) {
          var arr = optionsMap[value][field_optgroup];
          if (!arr) {
            optionsMap[value][field_optgroup] = group;
          } else if (!$.isArray(arr)) {
            optionsMap[value][field_optgroup] = [arr, group];
          } else {
            arr.push(group);
          }
        }
        return;
      }

      var option             = readData($option) || {};
      option[field_label]    = option[field_label] || $option.text();
      option[field_value]    = option[field_value] || value;
      option[field_optgroup] = option[field_optgroup] || group;

      optionsMap[value] = option;
      options.push(option);

      if ($option.is(&#39;:selected&#39;)) {
        settings_element.items.push(value);
      }
    };

    var addGroup = function($optgroup) {
      var i, n, id, optgroup, $options;

      $optgroup = $($optgroup);
      id = $optgroup.attr(&#39;label&#39;);

      if (id) {
        optgroup = readData($optgroup) || {};
        optgroup[field_optgroup_label] = id;
        optgroup[field_optgroup_value] = id;
        settings_element.optgroups.push(optgroup);
      }

      $options = $(&#39;option&#39;, $optgroup);
      for (i = 0, n = $options.length; i &lt; n; i++) {
        addOption($options[i], id);
      }
    };

    settings_element.maxItems = $input.attr(&#39;multiple&#39;) ? null : 1;

    $children = $input.children();
    for (i = 0, n = $children.length; i &lt; n; i++) {
      tagName = $children[i].tagName.toLowerCase();
      if (tagName === &#39;optgroup&#39;) {
        addGroup($children[i]);
      } else if (tagName === &#39;option&#39;) {
        addOption($children[i]);
      }
    }
  };

  return this.each(function() {
    if (this.selectize) return;

    var instance;
    var $input = $(this);
    var tag_name = this.tagName.toLowerCase();
    var placeholder = $input.attr(&#39;placeholder&#39;) || $input.attr(&#39;data-placeholder&#39;);
    if (!placeholder &amp;&amp; !settings.allowEmptyOption) {
      placeholder = $input.children(&#39;option[value=&quot;&quot;]&#39;).text();
    }

    var settings_element = {
      &#39;placeholder&#39; : placeholder,
      &#39;options&#39;     : [],
      &#39;optgroups&#39;   : [],
      &#39;items&#39;       : []
    };

    if (tag_name === &#39;select&#39;) {
      init_select($input, settings_element);
    } else {
      init_textbox($input, settings_element);
    }

    instance = new Selectize($input, $.extend(true, {}, defaults, settings_element, settings_user));
  });
};

$.fn.selectize.defaults = Selectize.defaults;
$.fn.selectize.support = {
  validity: SUPPORTS_VALIDITY_API
};

Selectize.define(&#39;drag_drop&#39;, function(options) {
  if (!$.fn.sortable) throw new Error(&#39;The &quot;drag_drop&quot; plugin requires jQuery UI &quot;sortable&quot;.&#39;);
  if (this.settings.mode !== &#39;multi&#39;) return;
  var self = this;

  self.lock = (function() {
    var original = self.lock;
    return function() {
      var sortable = self.$control.data(&#39;sortable&#39;);
      if (sortable) sortable.disable();
      return original.apply(self, arguments);
    };
  })();

  self.unlock = (function() {
    var original = self.unlock;
    return function() {
      var sortable = self.$control.data(&#39;sortable&#39;);
      if (sortable) sortable.enable();
      return original.apply(self, arguments);
    };
  })();

  self.setup = (function() {
    var original = self.setup;
    return function() {
      original.apply(this, arguments);

      var $control = self.$control.sortable({
        items: &#39;[data-value]&#39;,
        forcePlaceholderSize: true,
        disabled: self.isLocked,
        start: function(e, ui) {
          ui.placeholder.css(&#39;width&#39;, ui.helper.css(&#39;width&#39;));
          $control.css({overflow: &#39;visible&#39;});
        },
        stop: function() {
          $control.css({overflow: &#39;hidden&#39;});
          var active = self.$activeItems ? self.$activeItems.slice() : null;
          var values = [];
          $control.children(&#39;[data-value]&#39;).each(function() {
            values.push($(this).attr(&#39;data-value&#39;));
          });
          self.setValue(values);
          self.setActiveItem(active);
        }
      });
    };
  })();

});

Selectize.define(&#39;dropdown_header&#39;, function(options) {
  var self = this;

  options = $.extend({
    title         : &#39;Untitled&#39;,
    headerClass   : &#39;selectize-dropdown-header&#39;,
    titleRowClass : &#39;selectize-dropdown-header-title&#39;,
    labelClass    : &#39;selectize-dropdown-header-label&#39;,
    closeClass    : &#39;selectize-dropdown-header-close&#39;,

    html: function(data) {
      return (
        &#39;&lt;div class=&quot;&#39; + data.headerClass + &#39;&quot;&gt;&#39; +
          &#39;&lt;div class=&quot;&#39; + data.titleRowClass + &#39;&quot;&gt;&#39; +
            &#39;&lt;span class=&quot;&#39; + data.labelClass + &#39;&quot;&gt;&#39; + data.title + &#39;&lt;/span&gt;&#39; +
            &#39;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;&#39; + data.closeClass + &#39;&quot;&gt;&amp;times;&lt;/a&gt;&#39; +
          &#39;&lt;/div&gt;&#39; +
        &#39;&lt;/div&gt;&#39;
      );
    }
  }, options);

  self.setup = (function() {
    var original = self.setup;
    return function() {
      original.apply(self, arguments);
      self.$dropdown_header = $(options.html(options));
      self.$dropdown.prepend(self.$dropdown_header);
    };
  })();

});

Selectize.define(&#39;optgroup_columns&#39;, function(options) {
  var self = this;

  options = $.extend({
    equalizeWidth  : true,
    equalizeHeight : true
  }, options);

  this.getAdjacentOption = function($option, direction) {
    var $options = $option.closest(&#39;[data-group]&#39;).find(&#39;[data-selectable]&#39;);
    var index    = $options.index($option) + direction;

    return index &gt;= 0 &amp;&amp; index &lt; $options.length ? $options.eq(index) : $();
  };

  this.onKeyDown = (function() {
    var original = self.onKeyDown;
    return function(e) {
      var index, $option, $options, $optgroup;

      if (this.isOpen &amp;&amp; (e.keyCode === KEY_LEFT || e.keyCode === KEY_RIGHT)) {
        self.ignoreHover = true;
        $optgroup = this.$activeOption.closest(&#39;[data-group]&#39;);
        index = $optgroup.find(&#39;[data-selectable]&#39;).index(this.$activeOption);

        if(e.keyCode === KEY_LEFT) {
          $optgroup = $optgroup.prev(&#39;[data-group]&#39;);
        } else {
          $optgroup = $optgroup.next(&#39;[data-group]&#39;);
        }

        $options = $optgroup.find(&#39;[data-selectable]&#39;);
        $option  = $options.eq(Math.min($options.length - 1, index));
        if ($option.length) {
          this.setActiveOption($option);
        }
        return;
      }

      return original.apply(this, arguments);
    };
  })();

  var getScrollbarWidth = function() {
    var div;
    var width = getScrollbarWidth.width;
    var doc = document;

    if (typeof width === &#39;undefined&#39;) {
      div = doc.createElement(&#39;div&#39;);
      div.innerHTML = &#39;&lt;div style=&quot;width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;&quot;&gt;&lt;div style=&quot;width:1px;height:100px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;;
      div = div.firstChild;
      doc.body.appendChild(div);
      width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;
      doc.body.removeChild(div);
    }
    return width;
  };

  var equalizeSizes = function() {
    var i, n, height_max, width, width_last, width_parent, $optgroups;

    $optgroups = $(&#39;[data-group]&#39;, self.$dropdown_content);
    n = $optgroups.length;
    if (!n || !self.$dropdown_content.width()) return;

    if (options.equalizeHeight) {
      height_max = 0;
      for (i = 0; i &lt; n; i++) {
        height_max = Math.max(height_max, $optgroups.eq(i).height());
      }
      $optgroups.css({height: height_max});
    }

    if (options.equalizeWidth) {
      width_parent = self.$dropdown_content.innerWidth() - getScrollbarWidth();
      width = Math.round(width_parent / n);
      $optgroups.css({width: width});
      if (n &gt; 1) {
        width_last = width_parent - width * (n - 1);
        $optgroups.eq(n - 1).css({width: width_last});
      }
    }
  };

  if (options.equalizeHeight || options.equalizeWidth) {
    hook.after(this, &#39;positionDropdown&#39;, equalizeSizes);
    hook.after(this, &#39;refreshOptions&#39;, equalizeSizes);
  }

});

Selectize.define(&#39;remove_button&#39;, function(options) {
  options = $.extend({
      label     : &#39;&amp;times;&#39;,
      title     : &#39;Remove&#39;,
      className : &#39;remove&#39;,
      append    : true
    }, options);

    var singleClose = function(thisRef, options) {

      options.className = &#39;remove-single&#39;;

      var self = thisRef;
      var html = &#39;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;&#39; + options.className + &#39;&quot; tabindex=&quot;-1&quot; title=&quot;&#39; + escape_html(options.title) + &#39;&quot;&gt;&#39; + options.label + &#39;&lt;/a&gt;&#39;;

      /**
         Appends an element as a child (with raw HTML).

         @param {string} html_container
         @param {string} html_element
         @return {string}
        /
      var append = function(html_container, html_element) {
        return html_container + html_element;
      };

      thisRef.setup = (function() {
        var original = self.setup;
        return function() {
          // override the item rendering method to add the button to each
          if (options.append) {
            var id = $(self.$input.context).attr(&#39;id&#39;);
            var selectizer = $(&#39;#&#39;+id);

            var render_item = self.settings.render.item;
            self.settings.render.item = function(data) {
              return append(render_item.apply(thisRef, arguments), html);
            };
          }

          original.apply(thisRef, arguments);

          // add event listener
          thisRef.$control.on(&#39;click&#39;, &#39;.&#39; + options.className, function(e) {
            e.preventDefault();
            if (self.isLocked) return;

            self.clear();
          });

        };
      })();
    };

    var multiClose = function(thisRef, options) {

      var self = thisRef;
      var html = &#39;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;&#39; + options.className + &#39;&quot; tabindex=&quot;-1&quot; title=&quot;&#39; + escape_html(options.title) + &#39;&quot;&gt;&#39; + options.label + &#39;&lt;/a&gt;&#39;;

      /**
         Appends an element as a child (with raw HTML).

         @param {string} html_container
         @param {string} html_element
         @return {string}
        /
      var append = function(html_container, html_element) {
        var pos = html_container.search(/(&lt;\/[^&gt;]+&gt;\s*)$/);
        return html_container.substring(0, pos) + html_element + html_container.substring(pos);
      };

      thisRef.setup = (function() {
        var original = self.setup;
        return function() {
          // override the item rendering method to add the button to each
          if (options.append) {
            var render_item = self.settings.render.item;
            self.settings.render.item = function(data) {
              return append(render_item.apply(thisRef, arguments), html);
            };
          }

          original.apply(thisRef, arguments);

          // add event listener
          thisRef.$control.on(&#39;click&#39;, &#39;.&#39; + options.className, function(e) {
            e.preventDefault();
            if (self.isLocked) return;

            var $item = $(e.currentTarget).parent();
            self.setActiveItem($item);
            if (self.deleteSelection()) {
              self.setCaret(self.items.length);
            }
          });

        };
      })();
    };

    if (this.settings.mode === &#39;single&#39;) {
      singleClose(this, options);
      return;
    } else {
      multiClose(this, options);
    }
});

Selectize.define(&#39;restore_on_backspace&#39;, function(options) {
  var self = this;

  options.text = options.text || function(option) {
    return option[this.settings.labelField];
  };

  this.onKeyDown = (function() {
    var original = self.onKeyDown;
    return function(e) {
      var index, option;
      if (e.keyCode === KEY_BACKSPACE &amp;&amp; this.$control_input.val() === &#39;&#39; &amp;&amp; !this.$activeItems.length) {
        index = this.caretPos - 1;
        if (index &gt;= 0 &amp;&amp; index &lt; this.items.length) {
          option = this.options[this.items[index]];
          if (this.deleteSelection(e)) {
            this.setTextboxValue(options.text.apply(this, [option]));
            this.refreshOptions(true);
          }
          e.preventDefault();
          return;
        }
      }
      return original.apply(this, arguments);
    };
  })();
});

return Selectize;
</code></pre>

<p>}));</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </div>
  </body>
</html>
